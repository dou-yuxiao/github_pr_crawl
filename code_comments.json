[["  @Override\n  protected boolean ignorePotentiallyMisspelledWord(String word) throws IOException {\n    if (word.length() <= 5 || word.length() >= 40 || startsWithLowercase(word) || isProhibited(word)) {\n      // exclude weird/irrelevant cases (also the splitter can crash on VERY long words)\n      return false;\n    }\n    if (word.endsWith(\"gru√üe\") ||   // too big chance of a \"...gr√º√üe\" typo\n        word.endsWith(\"schaf\") ||  // too big chance of a \"...schaft\" typo\n        word.endsWith(\"schafs\") ||\n        word.endsWith(\"schafen\")\n    ) {\n      return false;\n    }\n    // Accept compounds with infix-s if both parts are known to the speller AND the first part\n    // ends with some specific chars, which indicate the need for the infix-s.\n    // Example: M√ºdigkeitsanzeichen = M√ºdigkeit + s + Anzeichen\n    // Deals with two-part compounds only and could be extended.\n    String wordNoDot = word.endsWith(\".\") ? word.substring(0, word.length()-1) : word;\n    List<String> parts = compoundTokenizer.tokenize(wordNoDot);\n    boolean nonStrictMode = false;\n    if (parts.size() == 1) {\n      parts = nonStrictCompoundTokenizer.tokenize(wordNoDot);\n      nonStrictMode = true;\n        String part2 = \" \";\n        for (String w : wordsWithoutInfixS) {  // wordsWithHyphen\n          if (word.startsWith(w))  {\n            part2 = word.substring(w.length());\n            if (part2.startsWith(\"-\")) {\n              part2 = part2.substring(1);\n            } else if (word.length() > w.length() && w.length() > 3) {\n              part2 = uppercaseFirstChar(part2.substring(0));\n            }\n            return (!isMisspelled(part2) || ignorePotentiallyMisspelledWord(part2)) && isNoun(part2);\n          }   \n      }\n    }\n    String part1;\n    String part2;\n    boolean hasInfixS = false;\n    if (parts.size() == 2) {\n      part1 = parts.get(0);\n      part2 = parts.get(1);\n      if (nonStrictMode && part2.startsWith(\"s\") && isMisspelled(part2) && !isMisspelled(uppercaseFirstChar(part2.substring(1)))) {\n        // nonStrictSplitter case, it splits like \"[Priorit√§t, sdings]\", we fix that here to match the strict splitter case:\n        part1 = part1 + \"s\";\n        part2 = part2.substring(1);\n        hasInfixS = true;\n      }\n    } else if (parts.size() == 3 && parts.get(1).equals(\"s\") && word.contains(\"-\") && startsWithUppercase(parts.get(2))) {\n      // e.g. \"Priorit√§ts-Dings\" gets split like \"Priorit√§t\", \"s\", \"dings\" -> treat it as if there was no \"-\":\n      part1 = parts.get(0) + \"s\";\n      part2 = lowercaseFirstChar(parts.get(2));\n      hasInfixS = true;\n    } else if (parts.size() == 3 && !word.contains(\"-\")) {\n      // e.g. Hundefutterschachtel = Hunde, Futter, Schachtel\n      part1 = parts.get(0);\n      part2 = parts.get(1);\n      String compound1 = parts.get(0) + parts.get(1);\n      String compound1noS = compound1.replaceFirst(\"s$\", \"\");\n      String compound2 = uppercaseFirstChar(parts.get(1)) + parts.get(2);\n      boolean compound1ok = false;\n      if (germanPrefixes.contains(part2)) {\n        compound1ok = \n          (((!isMisspelled(part1) && !isMisspelled(part1+parts.get(2))) ||  // Weink√ºhlschrank gets split into Wein, k√ºhl, schrank\n          ignorePotentiallyMisspelledWord(part1+parts.get(2))) &&\n          parts.get(2).length() >= 3) ||  //Vorraus --> Vor, rau, s\n          (!isMisspelled(compound1) || ignorePotentiallyMisspelledWord(compound1) ||   //Menschenrechtsdemos as 'rechts' is in germanPrefixes\n          !isMisspelled(compound1noS) || ignorePotentiallyMisspelledWord(compound1noS)); \n      } else {\n        compound1ok =\n          !isMisspelled(compound1) || ignorePotentiallyMisspelledWord(compound1) ||\n          !isMisspelled(compound1noS) || ignorePotentiallyMisspelledWord(compound1noS);\n      }\n      boolean compound2ok =\n        (!isMisspelled(compound2) || ignorePotentiallyMisspelledWord(compound2)) && isNoun(compound2);\n      return compound1ok && compound2ok;\n    } else {\n      // more than three parts can be supported later\n      return false;\n    }\n    if (word.contains(\"-\" + part2)) {\n      // don't accept e.g. \"Implementierungs-pflicht\"\n      return false;\n    }\n    // don't assume very short parts (like \"Ei\") are correct, these can easily be typos:\n    if ((hasInfixS || part1.endsWith(\"s\")) && part1.length() >= 4 /* includes 's' */ && part2.length() >= 3 && startsWithLowercase(part2)) {\n      String part1noInfix = part1.substring(0, part1.length()-1);\n      String part2uc = uppercaseFirstChar(part2);\n      if ((compoundPatternWithHeit.matcher(part1).matches() || wordsNeedingInfixS.contains(part1noInfix)) &&\n          isNoun(part2uc)) {\n        if (compoundPatternWithAction.matcher(part1noInfix).matches() ||\n            compoundPatternWithFirst.matcher(part2uc).matches() ||\n            part1.endsWith(\"schwungs\") || part1.endsWith(\"sprungs\") || isMisspelled(part1noInfix) || isMisspelled(part2uc)) {\n          return false;\n        }\n        return true;\n      }\n    }\n    String part2uc = uppercaseFirstChar(part2);\n    if (!hasInfixS &&\n        part1.length() >= 3 && part2.length() >= 4 &&\n        !part2.contains(\"-\") &&\n        startsWithLowercase(part2) &&\n        (wordsWithoutInfixS.contains(part1) || (compoundPatternSpecialEnding.matcher(part1).matches() && isNoun(part2uc))) &&\n        !isMisspelled(part1) &&\n        !isMisspelled(part2uc) &&\n        isMisspelled(part2) // don't accept e.g. \"Azubikommt\"\n      ) {\n      System.out.println(\"compound: \" + part1 + \" \" + part2 + \" (\" + word + \")\");\n      return true;\n    }\n    return false;\n  }", ["This stretch looks over-indented üôÉ"]], ["  @Test\n  public void testIgnoreMisspelledWord() throws IOException {\n    GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages(\"de\"), GERMAN_DE);\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Black-Friday-Schn√§ppchen\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Atmosph√§renkonzept\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"W√∂lkchenbildung\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Abschlussgru√üe\"));  // probably \"...gr√º√üe\"\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Offenlegungsfrist\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Offenlegungsfirst\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Dachfrist\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Hospizgemeinschaft\"));  //no infix-s for compounds: .*z + noun\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Azubikommt\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Wachtums-Pistole\"));  // split as \"Wacht, ums-Pistole\"\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Discorum\"));  // \"Disco, rum\" and \"rum\" is only 3 chars and thus too short\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Arbeitsgeber\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Arbeitsgeberverhandlungen\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Rechtlage\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Rechtextremismus\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Ausleihstelle\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Vorraus\")); \n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Weink√ºhlschrank\")); \n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Weinsk√ºhlschrank\")); \n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Weinssk√ºhlschrank\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Hundefutterschachtel\")); \n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Leistungsversuchstest\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Nachuntersuchungstest\"));  // needs extension in ExtendedGermanWordSplitter.extendedList (as of 2023-10-02)\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Robustheitsabst√§nde\"));  // triggers use of nonStrictSplitter (2023-09-18, might change...)\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Robustheitsabst√§nde.\"));  // triggers use of nonStrictSplitter (2023-09-18, might change...)\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Absenkungsvorgaben\"));  // triggers use of nonStrictSplitter (2023-09-26, might change...)\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Priorit√§tsdings\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Priorit√§tsdings.\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Haltungssch√§den\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Priorit√§ts-Dings\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Priorit√§ts-Dings.\"));\n    assertTrue(rule.ignorePotentiallyMisspelledWord(\"Haltungs-Sch√§den\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"haltungsch√§den\"));  // lowercase\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"haltungs-sch√§den\"));  // lowercase\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"haltungs-Sch√§den\"));  // lowercase\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Haltungsch√§den\"));  // missing infix-s\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Haltung-Sch√§den\"));  // missing infix-s\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Hultungssch√§den\"));  // misspelling in first word\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Hultungs-Sch√§den\"));  // misspelling in first word\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Haltungsscheden\"));  // misspelling in second part\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Haltungs-Scheden\"));  // misspelling in second part\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"HaltungsSch√§den\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Haltungsei\"));  // second part too short\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Haltungs-Ei\"));  // second part too short\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Leistungsnach\"));  // second part not a noun\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Antwortzugeschnitten\"));  // second part not a noun\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Leistungsgegangen\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Leistungsgegangen.\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Leistungsversuchstestnachweis\"));  // 4 or more parts not yet supported\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Leistung\"));  // not a compound\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Leistungs\"));  // not a compound\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Anschauungswiese\"));  // from prohibit.txt\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Fakult√§tsaal\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Implementierungs-pflicht\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Sachsenmeisterschaf\"));\n    // special cases:\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Actionsspa√ü\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Jungsnamen\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Aufschwungsphase\"));\n    assertFalse(rule.ignorePotentiallyMisspelledWord(\"Absprungsrate\"));\n  }", ["This tests the second condition:\r\n```java\r\nelse if (word.length() > w.length() && w.length() > 3)\r\n```\r\n\r\nBut **not** the first one:\r\n```java\r\nif (part2.startsWith(\"-\"))\r\n```\r\n\r\nAs someone who had to rubber-duck this to understand the rationale, it might be useful to also have a test for the second branch."]], ["  @Test\n  public void testHashCode() {\n    GlobalConfig config1 = new GlobalConfig();\n    GlobalConfig config2 = new GlobalConfig();\n\n    // Initially, both objects are empty, so their hash codes should be equal.\n    assertEquals(config1.hashCode(), config2.hashCode());\n\n    config1.setGrammalecteServer(\"server1\");\n    config2.setGrammalecteServer(\"server2\");\n\n    // After setting different servers, their hash codes should not be equal.\n    assertNotEquals(config1.hashCode(), config2.hashCode());\n\n    config1.setGrammalecteServer(\"server2\");\n\n    // When both objects have the same server, their hash codes should be equal again.\n    assertEquals(config1.hashCode(), config2.hashCode());\n\n    config1.setBeolingusFile(new File(\"file1\"));\n\n    // After setting different Beolingus files, their hash codes should not be equal.\n    assertNotEquals(config1.hashCode(), config2.hashCode());\n  }", ["Could you use a different property? beoLingus isn't used anymore and might soon be removed"]], ["  @Test\n  public void testHashCode() {\n    // Create a SentenceRange object\n    SentenceRange range = new SentenceRange(10, 20);\n\n    // Calculate the expected hash code\n    int expectedHashCode = 31 * (31 + 10) + 20;\n\n    // Test if the hashCode method returns the expected hash code\n    assertEquals(expectedHashCode, range.hashCode());\n  }", ["These comments are not needed"]], ["  @Override\n  public RuleMatch[] match(AnalyzedSentence sentence) {\n    List<RuleMatch> matches = new ArrayList<>();\n    AnalyzedTokenReadings[] tokens = getSentenceWithImmunization(sentence).getTokensWithoutWhitespace();\n    for (int i = 1; i < tokens.length; i++) {\n      AnalyzedTokenReadings token = tokens[i];\n      String tokenStr = token.getToken();\n      if (i + 1 < tokens.length && relevantWords.contains(tokenStr) && !isAllUppercase(tokenStr)) {\n        String ucToken = uppercaseFirstChar(tokenStr);\n        String lcToken = lowercaseFirstChar(tokenStr);\n        List<String> ucList = Arrays.asList(tokens[i - 1].getToken(), ucToken, tokens[i + 1].getToken());\n        List<String> lcList = Arrays.asList(tokens[i - 1].getToken(), lcToken, tokens[i + 1].getToken());\n        Probability ucProb = lm.getPseudoProbability(ucList);\n        Probability lcProb = lm.getPseudoProbability(lcList);\n        if (startsWithUppercase(tokenStr)) {\n          double ratio = lcProb.getProb() / ucProb.getProb();\n          if (ratio > THRESHOLD) {\n            String msg = \"Menar du verbet '\" + lcToken + \"'? Oftast √§r det initialf√∂rkotningar och egennamn som skrivs med stor bokstav.\";\n            RuleMatch match = new RuleMatch(this, sentence, token.getStartPos(), token.getEndPos(), msg);\n            match.setSuggestedReplacement(lcToken);\n            matches.add(match);\n          }\n        } else {\n          double ratio = ucProb.getProb() / lcProb.getProb();\n          if (ratio > THRESHOLD) {\n            String msg = \"Menar du substantivet '\" + ucToken + \"'? Oftast √§r det initialf√∂rkortningar och egennamn som skrivs med stor bokstav.\";\n            RuleMatch match = new RuleMatch(this, sentence, token.getStartPos(), token.getEndPos(), msg);\n            match.setSuggestedReplacement(ucToken);\n            matches.add(match);\n          }\n        }\n      }\n    }\n    return toRuleMatchArray(matches);\n  }", ["This is a copy of `UpperCaseNgramRule` for German, isn't it? We should avoid that kind of code duplication.", "These methods seem to be identical except the `String msg` part, aren't they? Then all the identical parts should be in a super class in `languagetool-core` and only the messages should be defined in the sub classes."]], ["  private void process(ImmutableSetMultimap<TypeElement, Element> validElements) {\n    for (Step step : steps) {\n      ImmutableSet<TypeElement> annotationTypes = getSupportedAnnotationTypeElements(step);\n      ImmutableSetMultimap<TypeElement, Element> stepElements =\n          new ImmutableSetMultimap.Builder<TypeElement, Element>()\n              .putAll(indexByAnnotation(elementsDeferredBySteps.get(step), annotationTypes))\n              .putAll(filterKeys(validElements, Predicates.in(annotationTypes)))\n              .build();\n      if (stepElements.isEmpty()) {\n        elementsDeferredBySteps.removeAll(step);\n      } else {\n        Set<? extends Element> rejectedElements =\n            step.process(toClassNameKeyedMultimap(stepElements));\n        elementsDeferredBySteps.replaceValues(\n            step,\n            transform(\n                rejectedElements,\n                (element) -> ElementName.forAnnotatedElement(element, typeUtils)));\n      }\n    }\n  }", ["I would not bother with the parentheses around `(element)`."]], ["  private ImmutableSetMultimap<TypeElement, Element> validElements(RoundEnvironment roundEnv) {\n    ImmutableSet<ElementName> prevDeferredElementNames = ImmutableSet.copyOf(deferredElementNames);\n    deferredElementNames.clear();\n\n    ImmutableSetMultimap.Builder<TypeElement, Element> deferredElementsByAnnotationBuilder =\n        ImmutableSetMultimap.builder();\n    for (ElementName deferredElementName : prevDeferredElementNames) {\n      Optional<? extends Element> deferredElement = deferredElementName.getElement(elementUtils);\n      if (deferredElement.isPresent()) {\n        findAnnotatedElements(\n            deferredElement.get(),\n            getSupportedAnnotationTypeElements(),\n            deferredElementsByAnnotationBuilder);\n      } else {\n        deferredElementNames.add(deferredElementName);\n      }\n    }\n\n    ImmutableSetMultimap<TypeElement, Element> deferredElementsByAnnotation =\n        deferredElementsByAnnotationBuilder.build();\n\n    ImmutableSetMultimap.Builder<TypeElement, Element> validElements =\n        ImmutableSetMultimap.builder();\n\n    Set<ElementName> validElementNames = new LinkedHashSet<>();\n\n    // Look at the elements we've found and the new elements from this round and validate them.\n    for (TypeElement annotationType : getSupportedAnnotationTypeElements()) {\n      Set<? extends Element> roundElements = roundEnv.getElementsAnnotatedWith(annotationType);\n      ImmutableSet<Element> prevRoundElements = deferredElementsByAnnotation.get(annotationType);\n      for (Element element : Sets.union(roundElements, prevRoundElements)) {\n        ElementName elementName = ElementName.forAnnotatedElement(element, typeUtils);\n        boolean isValidElement =\n            validElementNames.contains(elementName)\n                || (!deferredElementNames.contains(elementName)\n                    // For every element that is not module/package, to be well-informed its\n                    // enclosing-type in its entirety should be well-informed. Since modules\n                    // don't get annotated (and not supported here) they can be ignored.\n                    && validateElement(\n                        element.getKind() == ElementKind.PACKAGE\n                            ? element\n                            : getEnclosingType(element)));\n        if (isValidElement) {\n          validElements.put(annotationType, element);\n          validElementNames.add(elementName);\n        } else {\n          deferredElementNames.add(elementName);\n        }\n      }\n    }\n\n    return validElements.build();\n  }", ["We've generally used \"well-formed\" here.\r\nI think this comment could reasonably be moved before the variable declaration."]], ["    private ElementName(Element element) {\n      Objects.requireNonNull(element);\n      if (!isAcceptableElementKind(element)) {\n        throw new IllegalArgumentException(\n            String.format(\n                \"%s does not support element of kind %s.\",\n                this.getClass().getCanonicalName(), element.getKind()));\n      }\n    }", ["I think I wouldn't bother with this check. We can assume the switch-statement below is correct. Then we can remove the various implementations of this method."]], ["    static ElementName forAnnotatedElement(Element element, Types typeUtils) {\n      switch (element.getKind()) {\n        case PACKAGE:\n          return new PackageElementName(element);\n        case CLASS:\n        case ENUM:\n        case INTERFACE:\n        case ANNOTATION_TYPE:\n          return new TypeElementName(element);\n        case FIELD:\n        case ENUM_CONSTANT:\n          return new FieldElementName(element);\n        case CONSTRUCTOR:\n        case METHOD:\n          return new ExecutableElementName(element, typeUtils);\n        case PARAMETER:\n          return new ParameterElementName(element, typeUtils);\n        default:\n          throw new IllegalArgumentException(\n              String.format(\n                  \"%s does not support element type %s.\",\n                  ElementName.class.getCanonicalName(), element.getKind()));\n      }\n    }", ["I think we have a bit of an issue here. We're building for Java 8, so we can only directly reference elements that exist in that version. But I don't think we want to blow up with an exception if we encounter `RECORD` or `RECORD_COMPONENT` here, for example. Additionally, I think there are other elements that can be annotated and could therefore potentially end up here: `TYPE_PARAMETER` at least, right?\r\n\r\nI would use `MoreElements.isType` beforehand to handle the four type kinds that are currently here plus `RECORD`. I think then I would switch on `element.getKind().name()`, which is a bit ugly but does allow you to reference `RECORD_COMPONENT`. Finally, in the `default` I would not throw an exception but rather output a [note](https://docs.oracle.com/en/java/javase/18/docs/api/java.compiler/javax/annotation/processing/Messager.html#printNote(java.lang.CharSequence,javax.lang.model.element.Element)) about the problematic element.\r\n\r\n`RECORD_COMPONENT` remains something of a problem. I'm not sure I see a better alternative than to use reflection to call `getAccessor()`. The corresponding test could do something like [this one](https://github.com/google/auto/blob/de4299c1b717d878b0f13dd01f01997a9d2d3a32/value/src/test/java/com/google/auto/value/processor/AutoBuilderCompilationTest.java#L135)."]], ["    @Override\n    public int hashCode() {\n      return Objects.hash(qualifiedName);\n    }", ["I think `qualifiedName.hashCode()` would be fine here."]], ["    private boolean hasSameErasedParametersType(\n        ImmutableList<TypeMirror> execElementErasedParametersTypes) {\n      // TypeMirror needs to be compared using Types\n      if (erasedParametersTypes.size() != execElementErasedParametersTypes.size()) {\n        return false;\n      }\n      for (int i = 0; i < erasedParametersTypes.size(); i++) {\n        if (!typeUtils.isSameType(\n            erasedParametersTypes.get(i), execElementErasedParametersTypes.get(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }", ["I ran this change against all of Google's internal compilations and found a subtle problem. Let's say we have something like this:\r\n```java\r\npackage com.google.foo;\r\n\r\n@AutoFactory\r\npublic class Bar {\r\n  @SomeAnnotation\r\n  static void someMethod(BarFactory factory) {...}\r\n}\r\n```\r\n\r\n`BarFactory` is a class that is generated by the `@AutoFactory` processor. When the `@SomeAnnotation` processor runs, that class isn't available yet, so the reference to `BarFactory` is an `ErrorType`. `BasicAnnotationProcessor` correctly defers `someMethod` to the next round. But then `BarFactory` _is_ defined, it is a `DeclaredType`, and it fails `isSameType` when compared to the `ErrorType` from the first round.\r\n\r\nI _think_ this can probably be worked around by refining the check: `typeUtils.isSameType(a, b)` must be true, _or_ `a.getKind() == ERROR && typeUtils.asElement(a).getSimpleName().equals(typeUtils.asElement(b).getSimpleName())`. The second condition should be true for the case above. The only potential problem is that we might get a false match if there is _another_ overload of the same method using a class of the same name in a different package:\r\n\r\n```java\r\npackage com.google.foo;\r\n\r\n@AutoFactory\r\npublic class Bar {\r\n  @SomeAnnotation\r\n  static void someMethod(BarFactory factory) {...}\r\n\r\n  @SomeAnnotation\r\n  static void someMethod(com.google.baz.BarFactory factory) {...}\r\n}\r\n```\r\n\r\nThat seems extremely unlikely.\r\n\r\nAnyway I would suggest you add a test that reproduces the situation I described, verify that it fails with the code as it stands, and then figure out a solution, either the one I suggested or another one.\r\n\r\nMeanwhile I'm rerunning all those compilations with a version of this change that has the patch I suggested, and we'll see what that tells us.\r\n\r\nBTW I'm not sure the `ExecutableElementName.equals` method can behave completely correctly here, but it probably doesn't matter.", "I realize that the fix I suggested isn't really enough. We would also have to handle the case where we have `Set<BarFactory>`, `Set<? extends BarFactory>`, even a `<T extends BarFactory>` type parameter on the method. That would suggest writing a `TypeVisitor` similar to [the one](https://github.com/google/auto/blob/01bf873bba2b23e6c07d9451da4fc4f832b87a43/common/src/main/java/com/google/auto/common/MoreTypes.java#L190) used by `MoreTypes.equivalence()`.\r\n\r\nHowever!\r\n\r\nI think there is an easier way. What we're trying to do is to find this method again in a later round after we saw it in an earlier one. And the issue is that there might be other methods with the same name but different parameter types. But we should be able to rely on the specification of [`TypeElement.getEnclosedElements()`](https://docs.oracle.com/en/java/javase/17/docs/api/java.compiler/javax/lang/model/element/TypeElement.html#getEnclosedElements()), which essentially says that the elements will be returned in source order. That order shouldn't change between rounds, so you can just remember that this is the second method called `foo`, or even just the second element overall, to find it again. (That might fail if something like Lombok is hacking the AST, but I think that's an acceptable restriction.)\r\n\r\nI'm going to see if I can make this idea work and run it past all of Google's compilations again.", "Actually, we're looking at erased types, aren't we? So none of the cases I mentioned applies, though arrays do. Nevertheless I think this idea is probably cleaner than comparing the `getSimpleName()` of a `TypeElement` against the `getSimpleName()` of `typeUtils.asElement(errorType)`."]], ["  private static final ElementVisitor<Boolean, Void> ELEMENT_VALIDATING_VISITOR =\n      new AbstractElementVisitor6<Boolean, Void>() {\n        @Override public Boolean visitPackage(PackageElement e, Void p) {\n          // don't validate enclosed elements because it will return types in the package\n          return validateAnnotations(e.getAnnotationMirrors());\n        }\n\n        @Override public Boolean visitType(TypeElement e, Void p) {\n          TypeMirror superclass = e.getSuperclass();\n          return isValidBaseElement(e)\n              && validateElements(e.getTypeParameters())\n              && validateTypes(e.getInterfaces())\n              && validateType(superclass)\n              && validateElements(e.getInterfaces().stream().map(MoreTypes::asElement).collect(Collectors.toList()))\n              && (superclass.getKind() == TypeKind.NONE || validateElement(MoreTypes.asElement(superclass)));\n        }\n\n        @Override public Boolean visitVariable(VariableElement e, Void p) {\n          return isValidBaseElement(e);\n        }\n\n        @Override public Boolean visitExecutable(ExecutableElement e, Void p) {\n          AnnotationValue defaultValue = e.getDefaultValue();\n          return isValidBaseElement(e)\n              && (defaultValue == null || validateAnnotationValue(defaultValue, e.getReturnType()))\n              && validateType(e.getReturnType())\n              && validateTypes(e.getThrownTypes())\n              && validateElements(e.getTypeParameters())\n              && validateElements(e.getParameters());\n        }\n\n        @Override public Boolean visitTypeParameter(TypeParameterElement e, Void p) {\n          return isValidBaseElement(e)\n              && validateTypes(e.getBounds());\n        }\n\n        @Override public Boolean visitUnknown(Element e, Void p) {\n          // just assume that unknown elements are OK\n          return true;\n        }\n      }", ["Does `e.getInterfaces().stream(MoreTypes::asElement).allMatch(this::validateElement)`\r\n work?"]], ["  @Test\n  public void handlesRecursiveSuperinterface() {\n    JavaFileObject javaFileObject = JavaFileObjects.forSourceLines(\n        \"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"interface TestClass implements TestClass {}\");\n    assertAbout(javaSource())\n        .that(javaFileObject)\n        .processedWith(new AssertingProcessor() {\n          @Override\n          void runAssertions() {\n            assertWithMessage(\"Should not reach annotation processing.\").fail();\n          }\n        })\n        .failsToCompile();\n  }", ["Was this failing before this change? This seems like an outright error that should never call annotation processing"]], ["  @Test\n  public void missingGrandparentSuperclass() {\n    JavaFileObject javaFileObject = JavaFileObjects.forSourceLines(\n        \"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"class Parent extends Missing {}\",\n        \"\",\n        \"class TestClass extends Parent {}\");\n    assertAbout(javaSource())\n        .that(javaFileObject)\n        .processedWith(new AssertingProcessor() {\n          @Override\n          void runAssertions() {\n            TypeElement testClassElement =\n                processingEnv.getElementUtils().getTypeElement(\"test.TestClass\");\n            assertThat(SuperficialValidation.validateElement(testClassElement)).isFalse();\n          }\n        })\n        .failsToCompile();\n  }", ["Can you use multiple classes here? That stays with Google's Java style"]], ["  private static final ElementVisitor<Boolean, Void> ELEMENT_VALIDATING_VISITOR =\n      new AbstractElementVisitor6<Boolean, Void>() {\n        @Override public Boolean visitPackage(PackageElement e, Void p) {\n          // don't validate enclosed elements because it will return types in the package\n          return validateAnnotations(e.getAnnotationMirrors());\n        }\n\n        @Override public Boolean visitType(TypeElement e, Void p) {\n          TypeMirror superclass = e.getSuperclass();\n          return isValidBaseElement(e)\n              && validateElements(e.getTypeParameters())\n              && validateTypes(e.getInterfaces())\n              && validateType(superclass)\n              && e.getInterfaces().stream().map(MoreTypes::asElement).allMatch(SuperficialValidation::validateElement)\n              && (superclass.getKind() == TypeKind.NONE || validateElement(MoreTypes.asElement(superclass)));\n        }\n\n        @Override public Boolean visitVariable(VariableElement e, Void p) {\n          return isValidBaseElement(e);\n        }\n\n        @Override public Boolean visitExecutable(ExecutableElement e, Void p) {\n          AnnotationValue defaultValue = e.getDefaultValue();\n          return isValidBaseElement(e)\n              && (defaultValue == null || validateAnnotationValue(defaultValue, e.getReturnType()))\n              && validateType(e.getReturnType())\n              && validateTypes(e.getThrownTypes())\n              && validateElements(e.getTypeParameters())\n              && validateElements(e.getParameters());\n        }\n\n        @Override public Boolean visitTypeParameter(TypeParameterElement e, Void p) {\n          return isValidBaseElement(e)\n              && validateTypes(e.getBounds());\n        }\n\n        @Override public Boolean visitUnknown(Element e, Void p) {\n          // just assume that unknown elements are OK\n          return true;\n        }\n      }", ["If you want, `e -> validateElement(e)` is a little shorter than the method reference"]], ["    private int computePanelTopPosition(float slideOffset) {\n        int slidingViewHeight = mSlideableView != null ? mSlideableView.getMeasuredHeight() : 0;\n        int slidePixelOffset = (int) (slideOffset * mSlideRange);\n\n        // fix for issue #694\n        int bottomPanelValue = getMeasuredHeight() - getPaddingBottom() - mPanelHeight - slidePixelOffset;\n        int topPanelValue = getPaddingTop() - slidingViewHeight + mPanelHeight + slidePixelOffset;\n\n\n        // Compute the top of the panel if its collapsed\n        return mIsSlidingUp ? bottomPanelValue : topPanelValue;\n    }", ["The logic here looks exactly the same, can you elaborate how this is solving #694?\n"]], ["    @Override\n    public String routeServer(List<String> values, String key) {\n        //ÂàùÂßãÂåñÊùÉÈáçÊï∞ÊçÆ\n        // TODO: 2019-03-29 ÂêéÊúüËøõË°åÁºìÂ≠òÔºå‰∏çÁî®ÊØèÊ¨°ÈÉΩÈúÄË¶ÅÂ§ÑÁêÜÊùÉÈáç\n        initWeightData(values);\n\n        int index = ThreadLocalRandom.current().nextInt(Integer.parseInt(weigthTreeMap.lastKey()));\n        Map.Entry entry = weigthTreeMap.tailMap(String.valueOf(index), false).firstEntry();\n        String serverNode = String.valueOf(entry.getValue());\n        if (sameWeightNodes.contains(serverNode))\n            serverNode = new RandomHandle().routeServer(sameWeightNodes, key);\n        return serverNode;\n    }", ["`if else` ‰ª£Á†ÅÂùóËØ∑Áî® `{}` ÂåÖÂê´ÔºåÂèÇËÄÉÈòøÈáåÁöÑ Java ‰ª£Á†ÅËßÑËåÉÔºåÊúÄÂ•ΩÊòØÂú® idea ÈáåÁî®Â∑•ÂÖ∑Êâ´Êèè‰∏ÄÊ¨°„ÄÇ"]], ["        @Override\n        public int compare(Object o1, Object o2) {\n            if (Integer.parseInt((String) o1) > Integer.parseInt((String) o2))\n                return 1;\n            else return -1;\n        }", ["Âêå‰∏ä„ÄÇ"]], ["    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        final ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());\n        setContentView(binding.getRoot());\n\n        mFirebaseAppDistribution = FirebaseAppDistribution.getInstance();\n\n        binding.btShowNotification.setOnClickListener(view -> {\n            mFirebaseAppDistribution.showFeedbackNotification(\n                    \"Data Collection Notice\",\n                    InterruptionLevel.HIGH\n            );\n        });\n\n        binding.btSendFeedback.setOnClickListener(view -> {\n            mFirebaseAppDistribution.startFeedback(\"Thanks for sharing your feedback with us\");\n        });\n\n        askNotificationPermission();\n    }", ["Could you use the same example text as we use here: https://github.com/firebase/firebase-android-sdk/blob/46e7a69781b6651582be2ea9413cd6c30913b829/firebase-appdistribution/test-app/src/main/res/values/strings.xml#L3\r\n\r\nIf you'd rather use a string literal instead of a resource, feel free to leave out the \"link\" part."]], ["    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        final ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());\n        setContentView(binding.getRoot());\n\n        mFirebaseAppDistribution = FirebaseAppDistribution.getInstance();\n\n        binding.btShowNotification.setOnClickListener(view -> {\n            mFirebaseAppDistribution.showFeedbackNotification(\n                    \"Data Collection Notice\",\n                    InterruptionLevel.HIGH\n            );\n        });\n\n        binding.btSendFeedback.setOnClickListener(view -> {\n            mFirebaseAppDistribution.startFeedback(\"Thanks for sharing your feedback with us\");\n        });\n\n        askNotificationPermission();\n    }", ["Same comment as above about the example text."]], ["    private void askNotificationPermission() {\n        // This is only necessary for API level >= 33 (TIRAMISU)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) ==\n                    PackageManager.PERMISSION_GRANTED) {\n                // All set. We can post notifications\n            } else if (shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {\n                // Display an educational UI explaining to the user the features that will be enabled\n                // by them granting the POST_NOTIFICATION permission. This UI should provide the user\n                // \"OK\" and \"No thanks\" buttons. If the user selects \"OK,\" directly request the permission.\n                // If the user selects \"No thanks,\" allow the user to continue without notifications.\n            } else {\n                // Directly ask for the permission\n                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);\n            }\n        }\n    }", ["See here for an example from the test app in the SDK repo: https://github.com/firebase/firebase-android-sdk/blob/46e7a69781b6651582be2ea9413cd6c30913b829/firebase-appdistribution/test-app/src/main/kotlin/com/googletest/firebase/appdistribution/testapp/MainActivity.kt#L149"]], ["    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        final ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());\n        setContentView(binding.getRoot());\n\n        mFirebaseAppDistribution = FirebaseAppDistribution.getInstance();\n\n        binding.btShowNotification.setOnClickListener(view -> {\n            mFirebaseAppDistribution.showFeedbackNotification(\n                    \"Data Collection Notice\",\n                    InterruptionLevel.HIGH\n            );\n        });\n\n        binding.btSendFeedback.setOnClickListener(view -> {\n            mFirebaseAppDistribution.startFeedback(\"Thanks for sharing your feedback with us\");\n        });\n\n        askNotificationPermission();\n    }", ["I think a better modes for requesting permissions would be to call `askNotificationPermission()` only when the tester clicks the `btShowNotification` button. That would be more in line with the runtime permissions guidance: https://developer.android.com/training/permissions/requesting#workflow_for_requesting_permissions\r\n\r\nIn that case, you would call `FirebaseAppDistribution.showFeedbackNotification()` in the \"// All set. We can post notifications\" case in `askNotificationPermission()` below, and in the `sGranted == true` case in the `requestPermissionLauncher` initializer above."]], ["    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        // Hide the notification once this activity is destroyed\n        mFirebaseAppDistribution.cancelFeedbackNotification();\n    }", ["You shouldn't need this anymore now that we made the change to automatically hide the notification"]], ["    private void askNotificationPermission() {\n        // This is only necessary for API level >= 33 (TIRAMISU)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) ==\n                    PackageManager.PERMISSION_GRANTED) {\n                // All set. We can post notifications\n                showFeedbackNotification();\n            } else if (shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {\n                Log.i(TAG, \"Showing customer rationale for requesting permission.\");\n                new AlertDialog.Builder(this)\n                        .setMessage(\"Using a notification to initiate feedback to the developer. \" +\n                                \"To enable this feature, allow the app to post notifications.\"\n                        )\n                        .setPositiveButton(\"OK\", (dialogInterface, i) -> {\n                            Log.i(TAG, \"Launching request for permission.\");\n                            requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);\n                        })\n                        .setNegativeButton(\"No thanks\", (dialogInterface, i) -> Log.i(TAG, \"User denied permission request.\"))\n                        .show();\n            } else {\n                // Directly ask for the permission\n                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);\n            }\n        }\n    }", ["I don't think you want this check here anymore. Even if they are on an older device we still want to show the notification. On older devices the `checkSelfPermission()` call will return `true`."]], ["    public boolean isIgnoredClass(Class<?> viewClass) {\n        return mIgnoredClassSet.contains(viewClass);\n    }", ["This should be on the Utils class as this isn't really a configuration method.\n"]], ["    static boolean pullIgnoredFromView(Context context, AttributeSet attrs) {\n        if (attrs == null)\n            return false;\n\n        final String attributeName;\n        try {\n            attributeName = context.getResources().getResourceEntryName(R.attr.calligraphyIgnore);\n        } catch (Resources.NotFoundException e) {\n            // invalid attribute ID\n            return false;\n        }\n\n        return attrs.getAttributeBooleanValue(null, attributeName, false);\n    }", ["Can you add this as a separate pull-request.\n"]], ["    public boolean isIgnoredClass(Class<?> viewClass) {\n        return mIgnoredClassSet.contains(viewClass);\n    }", ["That should be in the Config. Just iterating across the list should not be done inside of the Config. Config should be just immutable state storage.\n"]], ["    @Test\n    public void testJvmMethodSorter() {\n        Method[] fromJvmWithSynthetics = DummySortJvm.class.getDeclaredMethods();\n        Method[] sorted = MethodSorter.getDeclaredMethods(DummySortJvm.class);\n\n        Comparator<Method> methodComparator = new Comparator<Method>() {\n            @Override\n            public int compare(Method m1, Method m2) {\n                int nameComparison = m1.getName().compareTo(m2.getName());\n                if (nameComparison != 0) {\n                    return nameComparison;\n                }\n                return m1.toString().compareTo(m2.toString());\n            }\n        };\n        \n        Arrays.sort(fromJvmWithSynthetics, methodComparator);\n        Arrays.sort(sorted, methodComparator);\n        \n        assertArrayEquals(fromJvmWithSynthetics, sorted);\n    }", ["This test now simply verifies that the two methods return the same values, ignoring order, so with these changes it's not a particularly good test.\r\n\r\nThe ordering of methods returned by `getDeclaredMethods()` is no longer guaranteed as of JDK 7. I think the only way to make this test useful but not flaky would be to skip the test if the JDK is 7 or greater."]], ["    private List<PotentialAssignment> generateAssignmentsFromTypeAlone(ParameterSignature unassigned) {\n        Class<?> paramType = unassigned.getType();\n\n        FromDataPoints fromDataPoints = unassigned.getAnnotation(FromDataPoints.class);\n        if (fromDataPoints == null) {\n            if (paramType.isEnum()) {\n                return new EnumSupplier(paramType).getValueSources(unassigned);\n            } else if (paramType.equals(Boolean.class) || paramType.equals(boolean.class)) {\n                return new BooleanSupplier().getValueSources(unassigned);\n            }\n        }\n        return emptyList();\n    }", ["For symmetry it would be nice to keep the `else`\r\n\r\n```suggestion\r\n        } else {\r\n            return emptyList();\r\n        }\r\n```"]], ["    private List<PotentialAssignment> generateAssignmentsFromTypeAlone(ParameterSignature unassigned) {\n        Class<?> paramType = unassigned.getType();\n\n        FromDataPoints fromDataPoints = unassigned.getAnnotation(FromDataPoints.class);\n        if (fromDataPoints == null) {\n            if (paramType.isEnum()) {\n                return new EnumSupplier(paramType).getValueSources(unassigned);\n            } else if (paramType.equals(Boolean.class) || paramType.equals(boolean.class)) {\n                return new BooleanSupplier().getValueSources(unassigned);\n            }\n        } else {\n            return emptyList();\n        }\n    }", ["‚ùì Shouldn't this check for `ParametersSuppliedBy` or, alternatively, shouldn't `SpecificDataPointsSupplier` throw an exception if it couldn't find a matching field?"]], ["    public int testCount() {\n        if (isTest()) {\n            return 1;\n        }\n        int conut = 0;\n        for (Description child : fChildren) {\n            conut += child.testCount();\n        }\n        return conut;\n    }", ["`count`?", "@euske I was going to fix this myself, but I can't because your pull request was made on your master branch. Please fix this and send us a new pull. This should work:\r\n\r\n```\r\n$ git branch -f master 7065f37\r\n$ put push -f master\r\n$ git checkout -b consisent-variable-names ce0d7c7\r\n$ git push --set-upstream origin consisent-variable-names \r\n```\r\n", "You also may want to change your `master` branch `main`. You can follow the \"What Your Teammates Have to Do\" instructions at https://www.git-tower.com/learn/git/faq/git-rename-master-to-main/\r\n\r\nI suggest fixing your master branch (following my previous instructions) first"]], ["        @Override\n        public void testAssumptionFailure(Failure failure) {\n            ignoreCount.getAndIncrement();\n        }", ["In #1294 (currently targeted for 4.13) we are proposing updating this class to collect assumption failure counts, so I am not sure we should make this change."]], ["        @Override\n        public void testAssumptionFailure(Failure failure) {\n            // do nothing: same as passing (for 4.5; may change in 4.6)\n        }", ["This is absolutely wrong. We rely on it!\r\nYou cannot remove the line. There is no field counter for assumptions and even if it was there, it is a change in behavior in all other frameworks and their integration tests will fail.", "@Tibor17 I suggest commenting on the bug."]], ["    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = testClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }", ["Curious why you want to call these directly vs. calling `classBlock()`.  If you cannot use `classBlock()` then perhaps instead of making these three `protected` we should extract one `protected` method that calls all three so 1) your runner isn't hard-coding the order and 2) we can add more calls in the future (ex `withClassFixtures()`). Perhaps call the new method `withClassStatements()`\n"]], ["    protected Statement withBeforeClasses(Statement statement) {\n        List<FrameworkMethod> befores = testClass\n                .getAnnotatedMethods(BeforeClass.class);\n        return befores.isEmpty() ? statement :\n                new RunBefores(statement, befores, null);\n    }", ["@PeterWippermann I don't understand what you mean by \"I can't call ParentRunner.classBlock(...) in my custom Runner because between invoking the children and applying the class statements, I'd like to apply @TestRules\". The method `withClassRules()` applies all of the rules annotated with `@ClassRule`. You shouldn't invoke rules annotated with `TestRule` in `ParentRunner` because there is no instance of the class.\n"]], ["    public List<Description> getTestRunsStarted() {\n        return fTestRunsStarted;\n    }", ["I know this code is \"just for testing\" but can we wrap the return value with `Collections.unmodifiableList()` ?\n"]], ["    @Override\n    public Object invoke(String currentPath, PathRef parent, Object model, EvaluationContext ctx, List<Parameter> parameters) {\n        if(ctx.configuration().jsonProvider().isArray(model)){\n            Iterable<?> objects = ctx.configuration().jsonProvider().toIterable(model);\n            Set<Object> objectSet = new HashSet<>();\n            objects.forEach(objectSet::add);\n\n            return  new ArrayList<>(objectSet);\n        }\n        throw new JsonPathException(\"Aggregation function attempted to calculate value using empty array\");\n    }", ["please make sure this function works with arrays of objects as well"]], ["    @Override\n    public Object invoke(String currentPath, PathRef parent, Object model, EvaluationContext ctx, List<Parameter> parameters) {\n        if(ctx.configuration().jsonProvider().isArray(model)){\n            Iterable<?> objects = ctx.configuration().jsonProvider().toIterable(model);\n            Set<Object> objectSet = new HashSet<>();\n            objects.forEach(objectSet::add);\n\n            return  new ArrayList<>(objectSet);\n        }\n        throw new JsonPathException(\"Aggregation function attempted to calculate value using empty array\");\n    }", ["I think Java Stream API can be used"]], ["    @Override\n    public Object invoke(String currentPath, PathRef parent, Object model, EvaluationContext ctx, List<Parameter> parameters) {\n        if(ctx.configuration().jsonProvider().isArray(model)){\n            Iterable<?> objects = ctx.configuration().jsonProvider().toIterable(model);\n            Set<Object> objectSet = new HashSet<>();\n            objects.forEach(objectSet::add);\n\n            return  new ArrayList<>(objectSet);\n        }\n        throw new JsonPathException(\"Aggregation function attempted to calculate value using empty array\");\n    }", ["```suggestion\r\n        if (ctx.configuration().jsonProvider().isArray(model)) {\r\n```"]], ["    @Override\n    public Object invoke(String currentPath, PathRef parent, Object model, EvaluationContext ctx, List<Parameter> parameters) {\n        if(ctx.configuration().jsonProvider().isArray(model)){\n            Iterable<?> objects = ctx.configuration().jsonProvider().toIterable(model);\n            Set<Object> objectSet = new HashSet<>();\n            objects.forEach(objectSet::add);\n\n            return  new ArrayList<>(objectSet);\n        }\n        throw new JsonPathException(\"Aggregation function attempted to calculate value using empty array\");\n    }", ["HashSet may change order"]], ["    @Override\n    public Object invoke(String currentPath, PathRef parent, Object model, EvaluationContext ctx, List<Parameter> parameters) {\n        if(ctx.configuration().jsonProvider().isArray(model)){\n\n            Iterable<?> objects = ctx.configuration().jsonProvider().toIterable(model);\n            List<Object> objectList = new ArrayList<>();\n            objects.forEach(objectList::add);\n            int targetIndex = this.targetIndex(ctx, parameters);\n            if (targetIndex >= 0) {\n                return objectList.get(targetIndex);\n            } else {\n                int realIndex = objectList.size() + targetIndex;\n                if (realIndex > 0) {\n                    return objectList.get(realIndex);\n                } else {\n                    throw new JsonPathException(\"Target index:\" + targetIndex + \" larger than object count:\" + objectList.size());\n                }\n            }\n        }\n        throw new JsonPathException(\"Aggregation function attempted to calculate value using non array\");\n    }", ["I guess it should go as a separate commit or even PR"]], ["    @Test\n    public void testDistinctOfObjects() throws Exception {\n        final Object EXPECTED_VALUE = new ObjectMapper().readValue(\"[{\\\"a\\\":\\\"a-val\\\"}, {\\\"b\\\":\\\"b-val\\\"}]\", Object.class);\n        verifyFunction(conf, \"$.objects.distinct()\", OBJECT_SERIES, EXPECTED_VALUE);\n    }", ["```suggestion\r\n        final Object expectedArray = new ObjectMapper().readValue(\"[{\\\"a\\\":\\\"a-val\\\"}, {\\\"b\\\":\\\"b-val\\\"}]\", Object.class);\r\n```"]], ["    @Test\n    public void testDistinctOfEmptyObjects() throws Exception {\n        final Object EXPECTED_VALUE = new ObjectMapper().readValue(\"[]\", Object.class);\n        verifyFunction(conf, \"$.empty.distinct()\", OBJECT_SERIES, EXPECTED_VALUE);\n    }", ["```suggestion\r\n        final Object expectedArray = new ObjectMapper().readValue(\"[]\", Object.class);\r\n```"]], ["    @Test\n    public void testDistinctOfObjects() throws Exception {\n        final Object expectedValue = new ObjectMapper().readValue(\"[{\\\"a\\\":\\\"a-val\\\"}, {\\\"b\\\":\\\"b-val\\\"}]\", Object.class);\n        verifyFunction(conf, \"$.objects.distinct()\", OBJECT_SERIES, expectedValue);\n    }", ["shouldn't `conf.mappingProvider()` be used instead of explicit creation of `ObjectMapper`?"]], ["    @Test\n    public void testDistinctOfEmptyObjects() throws Exception {\n        final Object expectedValue = new ObjectMapper().readValue(\"[]\", Object.class);\n        verifyFunction(conf, \"$.empty.distinct()\", OBJECT_SERIES, expectedValue);\n    }", ["shouldn't `conf.mappingProvider()` be used instead of explicit creation of `ObjectMapper`?"]], ["    private Upstream random(final int totalWeight, final int[] weights, final List<Upstream> upstreamList, final int length) {\n        // If the weights are not the same and the weights are greater than 0, then random by the total number of weights.\n        int offset = RANDOM.nextInt(totalWeight);\n        if (length <= 4) {\n            for (int i = 0; i < length; i++) {\n                if (offset < weights[i]) {\n                    return upstreamList.get(i);\n                }\n            }\n        } else {\n            int i = Arrays.binarySearch(weights, offset);\n            if (i < 0) {\n                i = -i - 1;\n            } else {\n                while (weights[i + 1] == offset) {\n                    i++;\n                }\n                i++;\n            }\n            return upstreamList.get(i);\n        }\n        return random(upstreamList);\n    }", ["why 4?", "when service lists are 5?"]], ["  @Test\n  public void execute_writesInputIfSet()\n      throws IOException, InterruptedException, ExecutionException {\n    CommandExecutor executor = new CommandExecutor(\"/bin/sh\", \"-c\", \"read in; echo $in\");\n    executor.setInput(\"1\");\n\n    Process process = executor.execute();\n    process.waitFor();\n\n    assertThat(executor.getOutput()).isEqualTo(\"1\\n\");\n  }", ["Please use the format functionUnderTest_condition_expectedResult\r\ne.g. something like execute_whenInputIsSet_writesInputToCommand"]], ["  public void setInput(String input) {\n    this.input = input;\n  }", ["Hm, it'd be nicer if we could set this in the constructor along with the arguments, though we can't easily do that atm because the constructor accepts \"String...\".\r\nIt's probably fine to leave this as is for now, but in the future we might want to change the constructor to something like CommandExecutor(String[] args, String input=\"\") (and update the plugins to use the new constructor)."]], ["    private static boolean containsNullCaseLabelElement(DetailAST detailAst) {\n        return TokenUtil.findFirstTokenByPredicate(detailAst, ast -> {\n            return ast.getFirstChild() != null\n                     && verifyNullCaseLabel(ast.getFirstChild()) != null;\n        }).isPresent();\n    }", ["Shouldn‚Äôt we be checking for the actual token, LITERAL_NULL?", ">but this is not working\r\n\r\nYou will need to examine the AST and see why, it is likely that LITERAL_NULL is a child of EXPR, as opposed to pattern variable definitions."]], ["    public void switchWithNullTest(SwitchInput i) {\n        switch (i) {\n            case FIRST -> System.out.println(\"FIRST\");\n            case SECOND -> System.out.println(\"SECOND\");\n            case null -> System.out.println(\"NULL\");\n        }\n    }", ["We need to extend test cases to have multiple case constants in one label, and null case constants in switch expressions."]], ["    public void switchWithNullTest(SwitchInput i) {\n        switch (i) {\n            case FIRST: i++;\n            case SECOND:  i++;\n            case null: i++;\n            case null: i++;\n        }\n    }", ["Please take the time to learn syntax and check that your inputs are compilable; duplicate case labels and postfix operators are not valid here."]], ["    @Test\n    public void testInputMissingSwitchDefaultCheckSwitchExpressionsFive() throws Exception {\n        final String[] expected = {\n            \"49:9: \" + getCheckMessage(MSG_KEY, \"default\"),\n        };\n        verifyWithInlineConfigParser(\n                getNonCompilablePath(\"InputMissingSwitchDefaultCheckSwitchExpressionsFive.java\"),\n            expected);\n    }", ["Similar to above, if we can't meaningfully name tests, we need to reconsider what we are testing."]], ["    private static DetailAST verifyNullCaseLabel(DetailAST ast) {\n        DetailAST returnValue = null;\n        for (DetailAST ast1 = ast; ast1 != null; ast1 = ast1.getNextSibling()) {\n            if (ast.getFirstChild() != null) {\n                final DetailAST value = ast.getFirstChild().getFirstChild();\n                if (value != null) {\n                    final String valueText = value.getText();\n                    if (Objects.equals(valueText, \"null\")) {\n                        returnValue = ast;\n                        break;\n                    }\n                }\n            }\n        }\n        return returnValue;\n    }", ["We must operate by tokens only."]], ["    private static DetailAST verifyNullCaseLabel(DetailAST ast) {\n        DetailAST returnValue = null;\n        for (DetailAST ast1 = ast; ast1 != null; ast1 = ast1.getNextSibling()) {\n            if (ast.getFirstChild() != null) {\n                final DetailAST value = ast.getFirstChild().getFirstChild();\n                if (value != null) {\n                    final String valueText = value.getText();\n                    if (Objects.equals(valueText, \"null\")) {\n                        returnValue = ast;\n                        break;\n                    }\n                }\n            }\n        }\n        return returnValue;\n    }", ["We have no need for any iteration here, we can and should be be much more deliberate about what we are checking."]], ["    public void nestedSwitch2() {\n        int i = 1, j = 2;\n        switch (i) {\n            case 1:\n                switch (j) {\n                    case 2:\n                        break;\n                    case 3:\n                        break;\n                    case null:\n                }\n            default:\n                break;\n        }\n\n        switch (i) { // violation\n\n        }\n    }", ["Primitives cannot be null. You will need to take time to understand Java and switch statement/expression syntax, and make sure that these test inputs make sense and compile locally."]], ["    public void nestedSwitch2() {\n        int i = 1, j = 2;\n        switch (i) {\n            case 1:\n                switch (j) {\n                    case 2:\n                        break;\n                    case 3:\n                        break;\n                    case null:\n                }\n            default:\n                break;\n        }\n\n        switch (i) { // violation\n\n        }\n    }", ["We have no need to tested nested switch statements in this PR, we can keep inputs concise."]], ["    @Test\n    public void testInputMissingSwitchDefaultCheckNullLabel1() throws Exception {\n        final String[] expected = {\n            \"49:9: \" + getCheckMessage(MSG_KEY, \"default\"),\n        };\n        verifyWithInlineConfigParser(\n                getNonCompilablePath(\"InputMissingSwitchDefaultCheckNullLabel.java\"),\n            expected);\n    }", ["Again, if we can't name test methods/inputs meaningfully, we need to reconsider the content and motivation behind them."]], ["    private static @Nullable DetailAST verifyNullCaseLabel(DetailAST ast, int tokenType) {\n        DetailAST returnValue = null;\n        if (ast.getFirstChild() != null) {\n            final DetailAST value = ast.getFirstChild().getFirstChild();\n            if (value != null && value.getType() == tokenType) {\n                returnValue = ast;\n            }\n        }\n        return returnValue;\n    }", ["This can be a simple boolean method with inlined return of conditions, please do this. We have no need to pass in token type here, there is only one place this is used. We can call this method `hasNullCaseLabel`."]], ["    private static boolean containsNullCaseLabelElement(DetailAST detailAst) {\n        return TokenUtil.findFirstTokenByPredicate(detailAst, ast -> {\n            return ast.getFirstChild() != null\n                     && verifyNullCaseLabel(ast.getFirstChild(), TokenTypes.LITERAL_NULL) != null;\n        }).isPresent();\n    }", ["```suggestion\r\n        return TokenUtil.findFirstTokenByPredicate(detailAst, MissingSwitchDefault::hasNullCaseLabel)\r\n                .isPresent();\r\n```"]], ["    public final void setIllegalPkgs(String... from) {\n        illegalPkgs = from.clone();\n        illegalPkgsRegexps.clear();\n        for (String illegalPkg : illegalPkgs) {\n            illegalPkgsRegexps.add(CommonUtil.createPattern(\"^(static|\" + illegalPkg + \")\\\\..*\"));\n        }\n    }", ["This is not much different from https://github.com/checkstyle/checkstyle/pull/13960#discussion_r1377565209 . This now looks like it can ignore the illegal package definition completely for the word `static`. Even if it can't be valid java to show that issue, this still doesn't seem right."]], ["    public void method2(int i) {\n        switch (i) {\n            case 1:\n                i++;\n                /* block */ /* Fallthru */ // comment\n            case 2: // violation 'Fall\\ through from previous branch of the switch statement'\n                // this is comment\n                i++;\n                // fall through\n        }\n    }", ["What is reason of such updates?\r\nIf no good reason let's not change, we usually not changing old test data .\r\nBut we can change violation comments."]], ["    public static void generate(String path, OutputStream out, String... moduleFolders)\n            throws IOException, CheckstyleException, MacroExecutionException {\n        JavadocMetadataScraper.resetModuleDetailsStore();\n\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n                        new DefaultConfiguration(JavadocMetadataScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n                new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n                new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(\"charset\", StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        checker.configure(defaultConfiguration);\n\n        checker.addListener(new MetadataGeneratorLogger(out, OutputStreamOptions.NONE));\n\n        final List<File> moduleFiles = getTargetFiles(path, moduleFolders);\n        final List<File> moduleFilesForNewMetadata = moduleFiles.stream().filter(file -> {\n            final String fileName = file.getName();\n            return MODULES_GENERATED_BY_NEW_FUNCTIONALITY.contains(fileName);\n        }).collect(Collectors.toList());\n        moduleFiles.removeAll(moduleFilesForNewMetadata);\n\n        checker.process(moduleFiles);\n\n        //////////////////////////////\n        // Plan:\n        // 1. Module name\n        //    - get from file name\n        //    - remove \"Check\"\n        // 2. Fully qualified name\n        //    clss.getName()\n        // 3. Parent\n        //    SiteUtil.getParentModule(clss)\n        // 4. ModuleType\n        //    - use getModuleType() from JavadocMetadataScraper\n        // 5. Description\n        //    - everything in javadoc is description\n        // 6. Violation message keys\n        //    - SiteUtil.getMessageKeys(clss)\n        //////////////////////////////\n        for (File file: moduleFilesForNewMetadata) {\n            final ModuleDetails moduleDetails = new ModuleDetails();\n\n            String moduleName = getModuleName(file);\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n\n            // TODO: Move to shared module, because that MacroExecutionException doesn't belong here\n            final Object instance = SiteUtil.getModuleInstance(moduleName);\n            final Class<?> clss = instance.getClass();\n            final String fullyQualifiedName = clss.getName();\n            moduleDetails.setFullQualifiedName(fullyQualifiedName);\n\n            final String parentModule = SiteUtil.getParentModule(clss);\n            final Object parentModuleInstance = SiteUtil.getModuleInstance(parentModule);\n            moduleDetails.setParent(parentModuleInstance.getClass().getName());\n\n            final ModuleType moduleType = getModuleType(moduleName);\n            moduleDetails.setModuleType(moduleType);\n\n            final Set<String> messageKeys = SiteUtil.getMessageKeys(clss);\n            moduleDetails.addToViolationMessages(new ArrayList<>(messageKeys));\n\n            final String className = getModuleName(file);\n            final Set<String> properties = SiteUtil.getPropertiesForDocumentation(clss, instance);\n            final Map<String, DetailNode> javadocs = SiteUtil\n                    .getPropertiesJavadocs(properties, className, file);\n            final DetailNode moduleJavadoc = javadocs.get(className);\n            moduleDetails.setDescription(constructSubTreeText(moduleJavadoc));\n\n            final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n            for (String property : properties) {\n                final ModulePropertyDetails propertyDetails = new ModulePropertyDetails();\n                propertyDetails.setName(property);\n\n                final DetailNode propertyJavadoc = javadocs.get(property);\n                String propertyDescription = constructSubTreeText(propertyJavadoc)\n                        .substring(\"Setter to \".length());\n                final String firstLetterCapitalized = propertyDescription.substring(0, 1)\n                    .toUpperCase(Locale.ROOT);\n                propertyDescription = firstLetterCapitalized + propertyDescription.substring(1);\n                propertyDetails.setDescription(propertyDescription);\n\n                final Field field = SiteUtil.getField(clss, property);\n                final Class<?> propertyType = SiteUtil.getFieldClass(field, property, className, instance);\n                propertyDetails.setType(propertyType.getName());\n\n                final String defaultValue = SiteUtil.getDefaultValue(property, field, instance, className);\n                final String defaultValueWihtoutQuotes = defaultValue.substring( 1, defaultValue.length() - 1 );\n                propertyDetails.setDefaultValue(defaultValueWihtoutQuotes);\n\n                moduleDetails.addToProperties(propertyDetails);\n            }\n\n            try {\n                XmlMetaWriter.write(moduleDetails);\n            }\n            catch (TransformerException | ParserConfigurationException ex) {\n                throw new IllegalStateException(\n                                \"Failed to write metadata into XML file for module: \"\n                                        + \"todoComment\", ex);\n            }\n        }\n\n    }", ["please move this block of code to new method."]], ["    public static void generate(String path, OutputStream out, String... moduleFolders)\n            throws IOException, CheckstyleException, MacroExecutionException {\n        JavadocMetadataScraper.resetModuleDetailsStore();\n\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n                        new DefaultConfiguration(JavadocMetadataScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n                new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n                new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(\"charset\", StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        checker.configure(defaultConfiguration);\n\n        checker.addListener(new MetadataGeneratorLogger(out, OutputStreamOptions.NONE));\n\n        final List<File> moduleFiles = getTargetFiles(path, moduleFolders);\n        final List<File> moduleFilesForNewMetadata = moduleFiles.stream().filter(file -> {\n            final String fileName = file.getName();\n            return MODULES_GENERATED_BY_NEW_FUNCTIONALITY.contains(fileName);\n        }).collect(Collectors.toList());\n        moduleFiles.removeAll(moduleFilesForNewMetadata);\n\n        checker.process(moduleFiles);\n\n        //////////////////////////////\n        // Plan:\n        // 1. Module name\n        //    - get from file name\n        //    - remove \"Check\"\n        // 2. Fully qualified name\n        //    clss.getName()\n        // 3. Parent\n        //    SiteUtil.getParentModule(clss)\n        // 4. ModuleType\n        //    - use getModuleType() from JavadocMetadataScraper\n        // 5. Description\n        //    - everything in javadoc is description\n        // 6. Violation message keys\n        //    - SiteUtil.getMessageKeys(clss)\n        //////////////////////////////\n        for (File file: moduleFilesForNewMetadata) {\n            final ModuleDetails moduleDetails = new ModuleDetails();\n\n            String moduleName = getModuleName(file);\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n\n            // TODO: Move to shared module, because that MacroExecutionException doesn't belong here\n            final Object instance = SiteUtil.getModuleInstance(moduleName);\n            final Class<?> clss = instance.getClass();\n            final String fullyQualifiedName = clss.getName();\n            moduleDetails.setFullQualifiedName(fullyQualifiedName);\n\n            final String parentModule = SiteUtil.getParentModule(clss);\n            final Object parentModuleInstance = SiteUtil.getModuleInstance(parentModule);\n            moduleDetails.setParent(parentModuleInstance.getClass().getName());\n\n            final ModuleType moduleType = getModuleType(moduleName);\n            moduleDetails.setModuleType(moduleType);\n\n            final Set<String> messageKeys = SiteUtil.getMessageKeys(clss);\n            moduleDetails.addToViolationMessages(new ArrayList<>(messageKeys));\n\n            final String className = getModuleName(file);\n            final Set<String> properties = SiteUtil.getPropertiesForDocumentation(clss, instance);\n            final Map<String, DetailNode> javadocs = SiteUtil\n                    .getPropertiesJavadocs(properties, className, file);\n            final DetailNode moduleJavadoc = javadocs.get(className);\n            moduleDetails.setDescription(constructSubTreeText(moduleJavadoc));\n\n            final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n            for (String property : properties) {\n                final ModulePropertyDetails propertyDetails = new ModulePropertyDetails();\n                propertyDetails.setName(property);\n\n                final DetailNode propertyJavadoc = javadocs.get(property);\n                String propertyDescription = constructSubTreeText(propertyJavadoc)\n                        .substring(\"Setter to \".length());\n                final String firstLetterCapitalized = propertyDescription.substring(0, 1)\n                    .toUpperCase(Locale.ROOT);\n                propertyDescription = firstLetterCapitalized + propertyDescription.substring(1);\n                propertyDetails.setDescription(propertyDescription);\n\n                final Field field = SiteUtil.getField(clss, property);\n                final Class<?> propertyType = SiteUtil.getFieldClass(field, property, className, instance);\n                propertyDetails.setType(propertyType.getName());\n\n                final String defaultValue = SiteUtil.getDefaultValue(property, field, instance, className);\n                final String defaultValueWihtoutQuotes = defaultValue.substring( 1, defaultValue.length() - 1 );\n                propertyDetails.setDefaultValue(defaultValueWihtoutQuotes);\n\n                moduleDetails.addToProperties(propertyDetails);\n            }\n\n            try {\n                XmlMetaWriter.write(moduleDetails);\n            }\n            catch (TransformerException | ParserConfigurationException ex) {\n                throw new IllegalStateException(\n                                \"Failed to write metadata into XML file for module: \"\n                                        + \"todoComment\", ex);\n            }\n        }\n\n    }", ["Put here name of module "]], ["    public static void generate(String path, OutputStream out, String... moduleFolders)\n            throws IOException, CheckstyleException, MacroExecutionException {\n        JavadocMetadataScraper.resetModuleDetailsStore();\n\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n                        new DefaultConfiguration(JavadocMetadataScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n                new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n                new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(\"charset\", StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        checker.configure(defaultConfiguration);\n\n        checker.addListener(new MetadataGeneratorLogger(out, OutputStreamOptions.NONE));\n\n        final List<File> moduleFiles = getTargetFiles(path, moduleFolders);\n        final List<File> moduleFilesForNewMetadata = moduleFiles.stream().filter(file -> {\n            final String fileName = file.getName();\n            return MODULES_GENERATED_BY_NEW_FUNCTIONALITY.contains(fileName);\n        }).collect(Collectors.toList());\n        moduleFiles.removeAll(moduleFilesForNewMetadata);\n\n        checker.process(moduleFiles);\n\n        //////////////////////////////\n        // Plan:\n        // 1. Module name\n        //    - get from file name\n        //    - remove \"Check\"\n        // 2. Fully qualified name\n        //    clss.getName()\n        // 3. Parent\n        //    SiteUtil.getParentModule(clss)\n        // 4. ModuleType\n        //    - use getModuleType() from JavadocMetadataScraper\n        // 5. Description\n        //    - everything in javadoc is description\n        // 6. Violation message keys\n        //    - SiteUtil.getMessageKeys(clss)\n        //////////////////////////////\n        for (File file: moduleFilesForNewMetadata) {\n            final ModuleDetails moduleDetails = new ModuleDetails();\n\n            String moduleName = getModuleName(file);\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n\n            // TODO: Move to shared module, because that MacroExecutionException doesn't belong here\n            final Object instance = SiteUtil.getModuleInstance(moduleName);\n            final Class<?> clss = instance.getClass();\n            final String fullyQualifiedName = clss.getName();\n            moduleDetails.setFullQualifiedName(fullyQualifiedName);\n\n            final String parentModule = SiteUtil.getParentModule(clss);\n            final Object parentModuleInstance = SiteUtil.getModuleInstance(parentModule);\n            moduleDetails.setParent(parentModuleInstance.getClass().getName());\n\n            final ModuleType moduleType = getModuleType(moduleName);\n            moduleDetails.setModuleType(moduleType);\n\n            final Set<String> messageKeys = SiteUtil.getMessageKeys(clss);\n            moduleDetails.addToViolationMessages(new ArrayList<>(messageKeys));\n\n            final String className = getModuleName(file);\n            final Set<String> properties = SiteUtil.getPropertiesForDocumentation(clss, instance);\n            final Map<String, DetailNode> javadocs = SiteUtil\n                    .getPropertiesJavadocs(properties, className, file);\n            final DetailNode moduleJavadoc = javadocs.get(className);\n            moduleDetails.setDescription(constructSubTreeText(moduleJavadoc));\n\n            final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n            for (String property : properties) {\n                final ModulePropertyDetails propertyDetails = new ModulePropertyDetails();\n                propertyDetails.setName(property);\n\n                final DetailNode propertyJavadoc = javadocs.get(property);\n                String propertyDescription = constructSubTreeText(propertyJavadoc)\n                        .substring(\"Setter to \".length());\n                final String firstLetterCapitalized = propertyDescription.substring(0, 1)\n                    .toUpperCase(Locale.ROOT);\n                propertyDescription = firstLetterCapitalized + propertyDescription.substring(1);\n                propertyDetails.setDescription(propertyDescription);\n\n                final Field field = SiteUtil.getField(clss, property);\n                final Class<?> propertyType = SiteUtil.getFieldClass(field, property, className, instance);\n                propertyDetails.setType(propertyType.getName());\n\n                final String defaultValue = SiteUtil.getDefaultValue(property, field, instance, className);\n                final String defaultValueWihtoutQuotes = defaultValue.substring( 1, defaultValue.length() - 1 );\n                propertyDetails.setDefaultValue(defaultValueWihtoutQuotes);\n\n                moduleDetails.addToProperties(propertyDetails);\n            }\n\n            try {\n                XmlMetaWriter.write(moduleDetails);\n            }\n            catch (TransformerException | ParserConfigurationException ex) {\n                throw new IllegalStateException(\n                                \"Failed to write metadata into XML file for module: \"\n                                        + \"todoComment\", ex);\n            }\n        }\n\n    }", ["I don't see usage of it."]], ["    private static ModuleType getModuleType(String moduleName) {\n        final ModuleType result;\n        if (moduleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (moduleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }", ["Are you sure in this ? \r\nAll Checks has name suffix \"Check\". \r\nThere are more modules like Holder, that we s bad hack but still we have them.", "Holders are still checks.\r\nhttps://github.com/checkstyle/checkstyle/blob/08814f209de43368cf9078a56e9175bf1f91f7a9/src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java#L63\r\nhttps://github.com/checkstyle/checkstyle/blob/08814f209de43368cf9078a56e9175bf1f91f7a9/src/main/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtil.java#L107-L108", "Ok, we will deal with this later on"]], ["    public static void generate(String path, OutputStream out, String... moduleFolders)\n            throws IOException, CheckstyleException, MacroExecutionException {\n        JavadocMetadataScraper.resetModuleDetailsStore();\n\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n                        new DefaultConfiguration(JavadocMetadataScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n                new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n                new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(\"charset\", StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        checker.configure(defaultConfiguration);\n\n        checker.addListener(new MetadataGeneratorLogger(out, OutputStreamOptions.NONE));\n\n        final List<File> moduleFiles = getTargetFiles(path, moduleFolders);\n        final List<File> moduleFilesForNewMetadata = moduleFiles.stream().filter(file -> {\n            final String fileName = file.getName();\n            return MODULES_GENERATED_BY_NEW_FUNCTIONALITY.contains(fileName);\n        }).collect(Collectors.toList());\n        moduleFiles.removeAll(moduleFilesForNewMetadata);\n\n        checker.process(moduleFiles);\n\n        //////////////////////////////\n        // Plan:\n        // 1. Module name\n        //    - get from file name\n        //    - remove \"Check\"\n        // 2. Fully qualified name\n        //    clss.getName()\n        // 3. Parent\n        //    SiteUtil.getParentModule(clss)\n        // 4. ModuleType\n        //    - use getModuleType() from JavadocMetadataScraper\n        // 5. Description\n        //    - everything in javadoc is description\n        // 6. Violation message keys\n        //    - SiteUtil.getMessageKeys(clss)\n        //////////////////////////////\n        for (File file: moduleFilesForNewMetadata) {\n            final ModuleDetails moduleDetails = new ModuleDetails();\n\n            String moduleName = getModuleName(file);\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n\n            // TODO: Move to shared module, because that MacroExecutionException doesn't belong here\n            final Object instance = SiteUtil.getModuleInstance(moduleName);\n            final Class<?> clss = instance.getClass();\n            final String fullyQualifiedName = clss.getName();\n            moduleDetails.setFullQualifiedName(fullyQualifiedName);\n\n            final String parentModule = SiteUtil.getParentModule(clss);\n            final Object parentModuleInstance = SiteUtil.getModuleInstance(parentModule);\n            moduleDetails.setParent(parentModuleInstance.getClass().getName());\n\n            final ModuleType moduleType = getModuleType(moduleName);\n            moduleDetails.setModuleType(moduleType);\n\n            final Set<String> messageKeys = SiteUtil.getMessageKeys(clss);\n            moduleDetails.addToViolationMessages(new ArrayList<>(messageKeys));\n\n            final String className = getModuleName(file);\n            final Set<String> properties = SiteUtil.getPropertiesForDocumentation(clss, instance);\n            final Map<String, DetailNode> javadocs = SiteUtil\n                    .getPropertiesJavadocs(properties, className, file);\n            final DetailNode moduleJavadoc = javadocs.get(className);\n            moduleDetails.setDescription(constructSubTreeText(moduleJavadoc));\n\n            final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n            for (String property : properties) {\n                final ModulePropertyDetails propertyDetails = new ModulePropertyDetails();\n                propertyDetails.setName(property);\n\n                final DetailNode propertyJavadoc = javadocs.get(property);\n                String propertyDescription = constructSubTreeText(propertyJavadoc)\n                        .substring(\"Setter to \".length());\n                final String firstLetterCapitalized = propertyDescription.substring(0, 1)\n                    .toUpperCase(Locale.ROOT);\n                propertyDescription = firstLetterCapitalized + propertyDescription.substring(1);\n                propertyDetails.setDescription(propertyDescription);\n\n                final Field field = SiteUtil.getField(clss, property);\n                final Class<?> propertyType = SiteUtil.getFieldClass(field, property, className, instance);\n                propertyDetails.setType(propertyType.getName());\n\n                final String defaultValue = SiteUtil.getDefaultValue(property, field, instance, className);\n                final String defaultValueWihtoutQuotes = defaultValue.substring( 1, defaultValue.length() - 1 );\n                propertyDetails.setDefaultValue(defaultValueWihtoutQuotes);\n\n                moduleDetails.addToProperties(propertyDetails);\n            }\n\n            try {\n                XmlMetaWriter.write(moduleDetails);\n            }\n            catch (TransformerException | ParserConfigurationException ex) {\n                throw new IllegalStateException(\n                                \"Failed to write metadata into XML file for module: \"\n                                        + \"todoComment\", ex);\n            }\n        }\n\n    }", ["Instead of setters, can we use all-argumets constructor of module details?\r\nAnd move all calculations of value to special methods.\r\n\r\nSo our code with look:\r\n```\r\nFinal String name = getFQN(....)\r\nObject parent = get parent(...)\r\n.....\r\nModuleDetails moduleDetails = new ModuleDetails(name, parent,.....)\r\n```\r\n\r\nSame for ModulePropertyDetails.\r\n\r\n"]], ["    private static String getPropertyDescription(String property, DetailNode propertyJavadoc) {\n        String propertyDescription;\n        if (SiteUtil.TOKENS.equals(property)) {\n            propertyDescription = \"tokens to check\";\n        }\n        else if (SiteUtil.JAVADOC_TOKENS.equals(property)) {\n            propertyDescription = \"javadoc tokens to check\";\n        }\n        else {\n            propertyDescription = SiteUtil\n                    .getDescriptionFromJavadoc(propertyJavadoc)\n                    .substring(\"Setter to \".length());\n            final String firstLetterCapitalized = propertyDescription\n                    .substring(0, 1)\n                    .toUpperCase(Locale.ROOT);\n            propertyDescription = firstLetterCapitalized + propertyDescription.substring(1);\n        }\n        return propertyDescription;\n    }", ["I am not sure why this method is specific for metadata.\r\nI think there should single method that does it for xdoc and meta and meta generation just reuse it \r\nSame for getPropertyDefaultValue\r\n\r\nIf agree please create separate issue to improve in separate PR"]], ["    public ModuleDetails() {\n        // empty constructor\n    }", ["Why do we need this? "]], ["    public ModulePropertyDetails() {\n        // empty constructor\n    }", ["Same as above, why do we need this?"]], ["        private static String getDescriptionFromJavadoc(DetailNode javadoc) {\n            DetailNode detailNode;\n\n            final Deque<DetailNode> stack = new ArrayDeque<>();\n            final List<DetailNode> descriptionNodes = getDescriptionNodes(javadoc);\n            Lists.reverse(descriptionNodes).forEach(stack::push);\n            final StringBuilder result = new StringBuilder(1024);\n            while (!stack.isEmpty()) {\n                detailNode = stack.pop();\n\n                Lists.reverse(Arrays.asList(detailNode.getChildren())).forEach(stack::push);\n\n                final String childText = detailNode.getText();\n                // Regular expression for detecting ANTLR tokens(for e.g. CLASS_DEF).\n                final Pattern tokenTextPattern = Pattern.compile(\"([A-Z_]{2,})+\");\n                if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                        && !tokenTextPattern.matcher(childText).matches()) {\n                    result.append(childText);\n                }\n            }\n            return result.toString().trim();\n        }", ["Unless I am missing something, we are not doing anything with `ANTLR tokens`, ANTLR is an internal detail of parser/AST implementation. Outside of these usages, these just become `JavadocTokenTypes`."]], ["    private static List<File> getFilesWhoseTemplateContainsPropertiesMacro(Iterable<File> files)\n            throws CheckstyleException, MacroExecutionException {\n        final List<Path> templatesWithPropertiesMacro =\n                SiteUtil.getTemplatesThatContainPropertiesMacro();\n        final List<File> filesWithPropertiesMacro = new ArrayList<>();\n        for (File file : files) {\n            final Path templatePath = SiteUtil.getTemplatePath(\n                SiteUtil.removeCheckSuffix(SiteUtil.getModuleName(file))\n            );\n            if (templatesWithPropertiesMacro.contains(templatePath)) {\n                filesWithPropertiesMacro.add(file);\n            }\n        }\n        return filesWithPropertiesMacro;\n    }", ["We are getting crazy with utility method usage and creation. Why can't we do a simple replace with `Check` as target?"]], ["    private static ModuleType getModuleType(String moduleName) {\n        final ModuleType result;\n        if (moduleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (moduleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }", ["Can we reuse/repurpose https://github.com/nrmancuso/checkstyle/blob/54616f662130aa0ca5afe45f72d36cdefb78a781/src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java#L572 ? This seems like a lot of duplication to me."]], ["    public static boolean isTokenNestedUnderContainerForAnonInners(DetailAST ast) {\n        boolean result = false;\n        DetailAST parentAst = ast.getParent();\n        while (parentAst != null) {\n            if (TokenUtil.isOfType(parentAst, CONTAINERS_FOR_ANON_INNERS)\n                    || parentAst.getType() == TokenTypes.LAMBDA) {\n                result = true;\n                break;\n            }\n            parentAst = parentAst.getParent();\n        }\n        return result;\n    }", ["Please rename this collection to something like `CLASS_BODY_DECLARATION_TOKENS`  or even `ANONYMOUS_INNER_CLASS_SCOPES` in a separate commit first, `container` is nonsense in this context. Then update the method naming, etc. appropriately.", "@rdiachenko , please step in to help review."]], ["            @Override\n            public void run() {\n                String j = hoo; // violation\n                String ja = foo; // ok\n                ja += \"asd\";\n            }", ["Please define violation messages ", "Hmm, I thought We started in all places to make it clear that violation message meaningful on a line, and it doesn't not create extra effort on new message addition.\r\n\r\n@rnveach , do you remember what is our rule for this now?", "We should have violation message for all violations, regardless of number of messages in check. This is a good sanity check, and will also alleviate extra work in the future if we add a new message.", "@romani @nrmancuso If it was NOT written down somewhere (either in code or the top of issues) or controlled by CI, then it doesn't exist. If this should be a rule, then a test should enforce it.\r\n\r\nhttps://github.com/checkstyle/checkstyle/issues/11214\r\n> Single Check might have multiple violations messages, we need to see exact violation message if Check has multiple messages, to be sure that violation of correct type is placed at right line.\r\n\r\nI consider this the main issue for this activity and it is documented only for checks with multiple messages. I scanned some of the checks listed and did not see any single message checks.\r\n\r\nhttps://github.com/checkstyle/checkstyle/blob/2335abaea101774a23d0bdaf55f19e4f0cad0d37/src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java#L118-L119\r\nhttps://github.com/checkstyle/checkstyle/blob/2335abaea101774a23d0bdaf55f19e4f0cad0d37/src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java#L411\r\nIt is even documented in code that it is only for checks with multiple messages.\r\n\r\n====================\r\n\r\nI was not involved in the discussions or the decision to do this, so I don't know anything more than, as I said, what is written.", "Thanks a lot.\r\nIf code checks for not single message, let's keep it and Finish phase of migration to update multiple messages Checks first.\r\nAnd maybe be later we will do same update for single-message, we will vote on this later on.\r\n\r\nI recall this review item for now.", "Thanks a lot.\r\nIf code checks for not single message, let's keep it and Finish phase of migration to update multiple messages Checks first.\r\nAnd maybe be later we will do same update for single-message, we will vote on this later on.\r\n\r\nI recall this review item for now."]], ["    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n\n        if (TokenUtil.isTypeDeclaration(parentType)) {\n            currentFrame.addDeclaredType(ast.getText());\n        }\n        else {\n            final boolean isPossibleDotClassOrInMethod = parentType == TokenTypes.DOT\n                    || parentType == TokenTypes.METHOD_DEF || parentType == TokenTypes.METHOD_REF;\n            final boolean isQualifiedIdent = parentType == TokenTypes.DOT\n                    && !TokenUtil.isOfType(ast.getPreviousSibling(), TokenTypes.DOT)\n                    && ast.getNextSibling() != null;\n            final boolean isQualifiedIdentFromMethodRef = isQualifiedIdentFromMethodRef(ast);\n            if (!isPossibleDotClassOrInMethod || isQualifiedIdent\n                    || isQualifiedIdentFromMethodRef) {\n                currentFrame.addReferencedType(ast.getText());\n            }\n        }\n    }", ["It would be better if this method did not care qualified identifier is from method ref specifically. Can we just create a helper method like `isQualifiedIdentifier` and handle all qualified identifiers there, i.e. move logic from `isQualifiedIdent` and `isQualifiedIdentFromMethodRef` to this helper method? ", "It would be good to make `processIdent` look like (psuedocode):\r\n```java\r\n\r\n// logic for booleans here\r\n\r\nif (isTypeDeclaration) {\r\n..\r\n}\r\nelse if (!isInClassOrMethod || isQualifiedIdentifier(ast)) {\r\n...\r\n}\r\n```"]], ["    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        final boolean isTypeDeclaration = TokenUtil.isTypeDeclaration(parentType);\n        final boolean isClassOrMethod = parentType == TokenTypes.DOT\n                || parentType == TokenTypes.METHOD_DEF || parentType == TokenTypes.METHOD_REF;\n\n        if (isTypeDeclaration) {\n            currentFrame.addDeclaredType(ast.getText());\n        }\n        else if (!isClassOrMethod || isQualifiedIdentifier(ast)) {\n            currentFrame.addReferencedType(ast.getText());\n        }\n    }", ["Please inline this in if statement like `if (TokenUtil.isTypeDeclaration(parentType))`, example above was only pseudocode."]], ["    private boolean isTerminated(final DetailAST ast, boolean useBreak,\n                                 boolean useContinue, Set<String> labels) {\n        final boolean terminated;\n\n        switch (ast.getType()) {\n            case TokenTypes.LITERAL_RETURN:\n            case TokenTypes.LITERAL_YIELD:\n            case TokenTypes.LITERAL_THROW:\n                terminated = true;\n                break;\n            case TokenTypes.LITERAL_BREAK:\n                terminated = useBreak\n                    || ast.getChildCount() == 2 && !labels.contains(ast.getFirstChild().getText());\n                break;\n            case TokenTypes.LITERAL_CONTINUE:\n                terminated = useContinue;\n                break;\n            case TokenTypes.SLIST:\n                terminated = checkSlist(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_IF:\n                terminated = checkIf(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_FOR:\n            case TokenTypes.LITERAL_WHILE:\n            case TokenTypes.LITERAL_DO:\n                terminated = checkLoop(ast, labels);\n                break;\n            case TokenTypes.LITERAL_TRY:\n                terminated = checkTry(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_SWITCH:\n                terminated = checkSwitch(ast, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_SYNCHRONIZED:\n                terminated = checkSynchronized(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LABELED_STAT:\n                labels.add(ast.getFirstChild().getText());\n                terminated = isTerminated(ast.getLastChild(), useBreak, useContinue, labels);\n                break;\n            default:\n                terminated = false;\n        }\n        return terminated;\n    }", ["Why isn't it enough to just check if a given `break` is breaking to a label? Why do we need label names? Is this to handle nested labels/switch when we traverse down different branches?", "Leaving this unresolved so that others can see it.", "infinite loop is outside of this Check targets. there are numerous way how to write infinite loop in such obfuscated way that non of tool will find it. "]], ["    @Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST nextGroup = ast.getNextSibling();\n        final boolean isLastGroup = nextGroup.getType() != TokenTypes.CASE_GROUP;\n        if (!isLastGroup || checkLastCaseGroup) {\n            final DetailAST slist = ast.findFirstToken(TokenTypes.SLIST);\n\n            if (slist != null && !isTerminated(slist, true, true, new HashSet<>())\n                && !hasFallThroughComment(ast, nextGroup)) {\n                if (isLastGroup) {\n                    log(ast, MSG_FALL_THROUGH_LAST);\n                }\n                else {\n                    log(nextGroup, MSG_FALL_THROUGH);\n                }\n            }\n        }\n    }", ["I don't use labels in Java code, but I noticed this is the only time we are \"erasing\" this labels list. We never seem to be removing anything from it, so things just keep growing.\r\n\r\nCan we have 2 very distinct sets of code in the same case group use the same label names? For example, this compiles for me:\r\n`````\r\n        int a = 0;\r\n        switch (a) {\r\n        case 0:\r\n            mylabel: while (a == 0) {\r\n                break mylabel;\r\n            }\r\n\r\n            int b = 0;\r\n            b++;\r\n\r\n            mylabel: while (b == 0) {\r\n                break mylabel;\r\n            }\r\n            break;\r\n        default:\r\n        }\r\n`````\r\nI also don't get any compile errors if a label is defined and never used.", "Like I said, I don't really use labels so I am not sure if I can go further.\r\n\r\nSo it doesn't matter where the label is located in terms of the check? It just seems odd we are not taking these contexts into account and only capturing a partial look of the code. We have had bugs where we were not emptying caches correctly, so I am just checking if there is possible issues with your code.", "@strkkk , I still think we should not care  about labels at all.\r\nread https://github.com/checkstyle/checkstyle/issues/11230#issuecomment-1055297662\r\n\r\nI am complaetely ok to to make note in description that we do not care where label of break is pointing, if it is present we consider it as good code for FallThrough.\r\n\r\nall madness with detection of infinite loop is out of this module consideration.", "I resolving this as I believe my concerns are not validated, but I still find it just odd that we don't care where the go to actually goes to and we are never doing any clean up."]], ["    private boolean isTerminated(final DetailAST ast, boolean useBreak,\n                                 boolean useContinue, Set<String> labels) {\n        final boolean terminated;\n\n        switch (ast.getType()) {\n            case TokenTypes.LITERAL_RETURN:\n            case TokenTypes.LITERAL_YIELD:\n            case TokenTypes.LITERAL_THROW:\n                terminated = true;\n                break;\n            case TokenTypes.LITERAL_BREAK:\n                terminated = useBreak\n                    || ast.getChildCount() == 2 && !labels.contains(ast.getFirstChild().getText());\n                break;\n            case TokenTypes.LITERAL_CONTINUE:\n                terminated = useContinue;\n                break;\n            case TokenTypes.SLIST:\n                terminated = checkSlist(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_IF:\n                terminated = checkIf(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_FOR:\n            case TokenTypes.LITERAL_WHILE:\n            case TokenTypes.LITERAL_DO:\n                terminated = checkLoop(ast, labels);\n                break;\n            case TokenTypes.LITERAL_TRY:\n                terminated = checkTry(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_SWITCH:\n                terminated = checkSwitch(ast, useContinue, labels);\n                break;\n            case TokenTypes.LITERAL_SYNCHRONIZED:\n                terminated = checkSynchronized(ast, useBreak, useContinue, labels);\n                break;\n            case TokenTypes.LABELED_STAT:\n                labels.add(ast.getFirstChild().getText());\n                terminated = isTerminated(ast.getLastChild(), useBreak, useContinue, labels);\n                break;\n            default:\n                terminated = false;\n        }\n        return terminated;\n    }", ["What about a continue label? We don't need similar label checking?", "Unless I am missing it, I am not seeing new test inputs for `continue <label>`. Please add some and also please regenerate regression. Will be interesting if anything new for `continue` comes up.\r\n\r\nEdit: I see a few but they are in the same file that is called `break`. I would just duplicate the file and swap all breaks for continue and have the files be similar of each other. Will a break ever behave differently than a continue in the context of this check?"]], ["    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void visitToken(DetailAST ast) {\n        final FileContents contents = getFileContents();\n        final int lineNo = ast.getLineNo();\n        final TextBlock cmt =\n            contents.getJavadocBefore(lineNo);\n        if (cmt == null) {\n            if (tag != null) {\n                log(lineNo, MSG_MISSING_TAG, tag);\n            }\n        }\n        else {\n            checkTag(lineNo, cmt.getText());\n        }\n    }", ["> Also note confusing violation message (\"null\" tag).\r\n\r\n@strkkk @romani So are we not resolving this in this issue or is this already another issue?", "We can do in this PR or separate , up to PR author.\r\n\r\nFyi, we are very close to merge at https://github.com/checkstyle/checkstyle/pull/12945", "We can do in this PR or separate , up to PR author.\r\n\r\nFyi, we are very close to merge at https://github.com/checkstyle/checkstyle/pull/12945"]], ["    private static int getTypeDeclarationNameMatchingCountDiff(String outerTypeDeclName,\n                                                               TypeDeclDesc firstTypeDecl,\n                                                               TypeDeclDesc secondTypeDecl) {\n        int diff = Integer.compare(\n            CheckUtil.getAnonSuperTypeMatchingCount(\n                outerTypeDeclName, secondTypeDecl.getQualifiedName()),\n            CheckUtil.getAnonSuperTypeMatchingCount(\n                outerTypeDeclName, firstTypeDecl.getQualifiedName()));\n        if (diff == 0) {\n            diff = Integer.compare(firstTypeDecl.getDepth(), secondTypeDecl.getDepth());\n        }\n        return diff;\n    }", ["this change is weird, naming is confusing. \r\nhost method is ` getTypeDeclarationNameMatchingCountDiff` and whole logic is in `getAnonSuperTypeMatchingCount`\r\n\r\nwhy \"AnnonSuper\"  is so critical ?\r\n\r\nit make sense for registerAnonymousInnerClassToSuperClass, but not in this context.\r\nlooks like getAnonSuperTypeMatchingCount name is root of confusion.", "it is ok to have different methods for each type of strucutre, but why \r\n`getTypeDeclarationNameMatchingCountDiff` is not\r\n`getAnnonTypeDeclarationNameMatchingCountDiff` ?\r\n\r\nas we use `CheckUtil.getAnonSuperTypeMatchingCount` in it.\r\n"]], ["    public static int getAnonSuperTypeMatchingCount(String patternTypeDeclaration,\n                                                     String typeDeclarationToBeMatched) {\n        final int typeDeclarationToBeMatchedLength = typeDeclarationToBeMatched.length();\n        final int minLength = Math\n            .min(typeDeclarationToBeMatchedLength, patternTypeDeclaration.length());\n        final boolean shouldCountBeUpdatedAtLastCharacter =\n            typeDeclarationToBeMatchedLength > minLength\n                && typeDeclarationToBeMatched.charAt(minLength) == PACKAGE_SEPARATOR;\n\n        int result = 0;\n        for (int idx = 0;\n             idx < minLength\n                 && patternTypeDeclaration.charAt(idx) == typeDeclarationToBeMatched.charAt(idx);\n             idx++) {\n\n            if (idx == minLength - 1 && shouldCountBeUpdatedAtLastCharacter\n                || patternTypeDeclaration.charAt(idx) == PACKAGE_SEPARATOR) {\n                result = idx;\n            }\n        }\n        return result;\n    }", ["I think you need to remove \"AnonSuper\" from name, I do not see any reference to this terms in body."]], ["    private static TypeDeclDesc getTheNearestClass(String outerTypeDeclName,\n            List<TypeDeclDesc> typeDeclWithSameName) {\n        return Collections.min(typeDeclWithSameName, (first, second) -> {\n            return getAnonTypeDeclarationNameMatchingCountDiff(outerTypeDeclName, first, second);\n        });\n    }", ["```\r\nprivate static TypeDeclDesc getTheNearestClass(....\r\n\r\n   return getAnonTypeDeclaration\r\n```\r\n\r\nWhy Nearest is always Anon class ? \r\nlooks like we need to rename getTheNearestClass to getTheNearestAnonClass", "Usually super class mean class that we extended. Do you mean nesting class? Class that nest another class ", "ok , we search class name for anonymous class.\r\nso `getTheNearestClass ..... by means of ... getTypeDeclarationNameMatchingCountDiff` is logical\r\nyou propose\r\nso `getTheNearestClass ..... by means of ...  getAnonTypeDeclarationNameMatchingCountDiff` that sounds strange and nonsense.\r\n\r\nproblems is name of `public static int getAnonSuperTypeMatchingCount(String patternTypeDeclaration`\r\nyou renamed to be `AnonSuper` but name should stay and handing of nested properly in addition is details of implementation.\r\n", "please do me a favor and rename \r\n`getTheNearestClass`\r\nto \r\n`getTheNearestClassOfAnonInnerClass`\r\n to make it clear it is not general method but very specific for anonymous and it it is not only do min of collection , it actually does `getAnon.......` so it is fully Anon related method.\r\n\r\njust name of method should be changed.\r\n\r\n![image](https://github.com/checkstyle/checkstyle/assets/812984/7b440ba6-4395-4a0d-9cf4-9aa774c221ba)\r\n", "I renaming it myself to stop this conversation today."]], ["    private static int typeDeclarationNameMatchingCount(String patternClass,\n                                                       String classToBeMatched) {\n        final int length = Math.min(classToBeMatched.length(), patternClass.length());\n        int result = 0;\n        for (int idx = 0;\n             idx < length && patternClass.charAt(idx) == classToBeMatched.charAt(idx);\n             ++idx) {\n            if (patternClass.charAt(idx) == PACKAGE_SEPARATOR.charAt(0)) {\n                result = idx;\n            }\n        }\n        return result;\n    }", ["Ok, both this method and `getAnonSuperTypeMatchingCount` are hard to understand, and bring up a lot of questions (why prefix ++ sometimes, etc.). Additionally, when we find the next bug, it is tempting to extend logic within the loops, so my concern is also for maintainability.\r\n\r\nIs there a reason that we cannot use a more general approach to both of these methods? Something like:\r\n1. Turn both strings into lists of type Character\r\n2. Take intersection of lists\r\n3. Remove everything after after final `.`\r\n4. Apply any special logic\r\n5. Return count of remaining characters\r\n\r\n1-3 could certainly be extracted to some util method like 'String getIntersection(String x, String y)`. Then, each one of these \"specialty\" methods can apply custom logic and return a count."]], ["    @Override\n    protected void setupChild(Configuration childConf)\n            throws CheckstyleException {\n        final String name = childConf.getName();\n        final Object child;\n\n        try {\n            child = moduleFactory.createModule(name);\n\n            final AbstractAutomaticBean bean = (AbstractAutomaticBean) child;\n            bean.contextualize(childContext);\n            bean.configure(childConf);\n        }\n        catch (final CheckstyleException ex) {\n            throw new CheckstyleException(\"cannot initialize module \" + name\n                    + \" - \" + ex.getMessage(), ex);\n        }\n        if (child instanceof FileSetCheck) {\n            final FileSetCheck fsc = (FileSetCheck) child;\n            fsc.init();\n            fsc.setMessageDispatcher(this);\n            fileSetChecks.add(fsc);\n        }\n        else if (child instanceof BeforeExecutionFileFilter) {\n            final BeforeExecutionFileFilter filter = (BeforeExecutionFileFilter) child;\n            beforeExecutionFileFilters.addBeforeExecutionFileFilter(filter);\n        }\n        else if (child instanceof Filter) {\n            final Filter filter = (Filter) child;\n            filters.addFilter(filter);\n        }\n        else if (child instanceof AuditListener) {\n            final AuditListener listener = (AuditListener) child;\n            listeners.add(listener);\n        }\n        else {\n            throw new CheckstyleException(name\n                    + \" is not allowed as a child in Checker\");\n        }\n    }", ["why we try to not use addXXXX methods ? in this specific case it is not single statement wrapper.", "this most likely an answer - https://github.com/checkstyle/checkstyle/pull/12511/files#r1046651114", "does it make sense do make private method something line `addFileSetCheckInternal` to keep two statement together.", "if we do this update only for future update, lets not do this now, it is very small, it will looks more natural in next PR when addListenter start to have new code that we do not want to apply each time.", "@rnveach , please reply.", "this method was used only here\r\n![image](https://github.com/checkstyle/checkstyle/assets/812984/dac3383c-906a-4efb-b549-8c4c1282905f)\r\n\r\nit is public, so theoretically can be used by plugins, but we are kind deprecating it ? we need to figureout how much it will affect plugins/extensions."]], ["    @Override\n    protected void setupChild(Configuration childConf)\n            throws CheckstyleException {\n        final String name = childConf.getName();\n        final Object child;\n\n        try {\n            child = moduleFactory.createModule(name);\n\n            final AbstractAutomaticBean bean = (AbstractAutomaticBean) child;\n            bean.contextualize(childContext);\n            bean.configure(childConf);\n        }\n        catch (final CheckstyleException ex) {\n            throw new CheckstyleException(\"cannot initialize module \" + name\n                    + \" - \" + ex.getMessage(), ex);\n        }\n        if (child instanceof FileSetCheck) {\n            final FileSetCheck fsc = (FileSetCheck) child;\n            fsc.init();\n            fsc.setMessageDispatcher(this);\n            fileSetChecks.add(fsc);\n        }\n        else if (child instanceof BeforeExecutionFileFilter) {\n            final BeforeExecutionFileFilter filter = (BeforeExecutionFileFilter) child;\n            beforeExecutionFileFilters.addBeforeExecutionFileFilter(filter);\n        }\n        else if (child instanceof Filter) {\n            final Filter filter = (Filter) child;\n            filters.addFilter(filter);\n        }\n        else if (child instanceof AuditListener) {\n            final AuditListener listener = (AuditListener) child;\n            listeners.add(listener);\n        }\n        else {\n            throw new CheckstyleException(name\n                    + \" is not allowed as a child in Checker\");\n        }\n    }", ["removal of this IF can mean breaking changes, as some thirdparty modules might stop to work.\r\nIf module does not need properties or any Checkers/Treewalker properties, it is ok to be not AbstractAutomaticBean, even we do not recommend it and highly expect.\r\n\r\nlets keep it as it was before, with IF, to not deal with breaking old and not not well done modules. At least we need to consider to make it as separate and very explicit breaking change.", "lets restore this block and add pitest to suppression for now to clearly see it. As we agree on PR , covering pitest will be final polishing."]], ["    public void persist() throws IOException {\n        final Path path = Paths.get(fileName);\n        final Path directory = path.getParent();\n        if (directory != null) {\n            // createDirectories throws an error if the target directory exists and is a symbolic link,\n            // skip call if the directory already exists\n            if (!directory.toFile().isDirectory())\n                Files.createDirectories(directory);\n        }\n        try (OutputStream out = Files.newOutputStream(path)) {\n            details.store(out, null);\n        }\n    }", ["Please add test on this, it is ok to have it only Linux specific ", "Java has special method to check if file is a link https://docs.oracle.com/javase/tutorial/essential/io/links.html#:~:text=To%20determine%20whether%20a%20Path,isSymbolicLink(file)%3B\r\n\r\nBetter to use it.", "Creation on link on window is admin level privilege https://www.google.com/amp/s/www.geeksforgeeks.org/creating-symbolic-links-on-windows/amp/ so test coverage will be OS specific, so needs to be skipped by jacoco and pitest.\r\n\r\nhttps://stackoverflow.com/a/28982854/1015848"]], ["    @Test\n    public void testOverloadDescriptorEquals()\n            throws Exception {\n        final Class<?> inner =\n            TestUtil.getInnerClassType(OverloadMethodsDeclarationOrderCheck.class,\n                                       \"OverloadDescriptor\");\n        final Constructor<?> constructor = inner.getDeclaredConstructors()[0];\n        constructor.setAccessible(true);\n        final Pattern pattern1 = Pattern.compile(\".*\");\n        final Object descriptor1 =\n            constructor.newInstance(pattern1, \"foo\", null, 1);\n\n        final Object comparison = null;\n        assertWithMessage(\"Should not be equal to null\")\n            .that(descriptor1.equals(comparison))\n            .isFalse();\n\n        assertWithMessage(\"Should not be equal to another class\")\n            .that(descriptor1.equals(new Object()))\n            .isFalse();\n\n        final Pattern pattern2 = Pattern.compile(\"^public$\");\n        final Object descriptor2 =\n            constructor.newInstance(pattern2, \"foo\", null, 1);\n        assertWithMessage(\"Should not be equal to another pattern\")\n            .that(descriptor1.equals(descriptor2))\n            .isFalse();\n\n        final Object descriptor3 =\n            constructor.newInstance(pattern1, \"bar\", null, 1);\n        assertWithMessage(\"Should not be equal to another method name\")\n            .that(descriptor1.equals(descriptor3))\n            .isFalse();\n    }", ["Pure unit test is not much better than suppression, we avoid extension of our technical debt at all costs. Please remove this test to let us see all and work through pitest failures. If code is problematic, remove it and run check regression report in order to find test cases to cover new code.", "We will not extend our technical debt, if we have this much code that we cannot hit, it is time to rethink implementation. "]], ["    @Test\n    public void testDefault() throws Exception {\n\n        final String[] expected = {\n            \"32:5: \" + getCheckMessage(MSG_KEY, 21),\n            \"60:9: \" + getCheckMessage(MSG_KEY, 49),\n            \"72:5: \" + getCheckMessage(MSG_KEY, 70),\n            \"115:5: \" + getCheckMessage(MSG_KEY, 104),\n        };\n        verifyWithInlineConfigParser(\n            getPath(\"InputOverloadMethodsDeclarationOrder.java\"), expected);\n    }", ["Please revert all formatting changes."]], ["    private void checkOverloadMethodsGrouping(DetailAST objectBlock) {\n        final int allowedDistance = 1;\n        final Map<String, IndexAndLine> knownMethods = new HashMap<>();\n        DetailAST currentToken = objectBlock.getFirstChild();\n\n        int currentIndex = 0;\n        while (currentToken != null) {\n            if (currentToken.getType() == TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodKey = extractMethodDescription(currentToken);\n                final IndexAndLine indexAndLine =\n                    new IndexAndLine(currentIndex, currentToken.getLineNo());\n                final IndexAndLine previousMeta = knownMethods.put(methodKey, indexAndLine);\n                if (previousMeta != null\n                    && currentIndex - previousMeta.getIndex() > allowedDistance) {\n                    final int previousLineWithOverloadMethod = previousMeta.getLineNo();\n                    log(currentToken, MSG_KEY, previousLineWithOverloadMethod);\n                }\n            }\n            currentToken = currentToken.getNextSibling();\n        }\n    }", ["Can we use a list of `MethodDetails`as proposed below?", "@austinarbor this is a good point; I like the map implementation, but I am not a big fan of the \"description string\". This string seems difficult to reason about/ debug in future maintenance. What do you think about `Map<MethodDetails, Integer> knownMethods`, where integer is the index and we store the line number in `MethodDetails`?\r\n\r\nMethodDetails could be something like line number, method name, and matching modifier group pattern.\r\n", "Yes, it has been awhile since we looked at first iteration, thanks for the reminder. One last thought; what do you think of using a simple data class that contains the same information? We could do `Map<MethodDetails, IndexAndLine>` where `MethodDetails` is comprised of the pattern and method name?", "It shouldn‚Äôt, since we do not need to override equals/hashcode in this case, right?", ">Why wouldn't we?\r\n\r\nI was thinking of some hack with custom map, but this is not good either. Let's proceed with custom description string then, we can get all test cases and behavior of update correct first and give us some time to think on this. It would be awesome to be able to do method name -> method details map with patterns, but I do not think this will work correctly with new feature."]], ["    private static String extractModifiersString(final DetailAST token) {\n        final DetailAST modifiersAst = token.findFirstToken(TokenTypes.MODIFIERS);\n        final List<String> collectedModifiers = new LinkedList<>();\n        DetailAST modifier = modifiersAst.getFirstChild();\n        boolean foundScopeModifier = false;\n        while (modifier != null) {\n            // skipping annotations\n            if (modifier.getType() != TokenTypes.ANNOTATION) {\n                final String currModifierText = modifier.getText();\n                if (!foundScopeModifier) {\n                    // no need to test again if scope modifier already found\n                    foundScopeModifier = isScopeModifier(currModifierText);\n                }\n\n                collectedModifiers.add(currModifierText);\n            }\n\n            // advance element in loop\n            modifier = modifier.getNextSibling();\n        }\n\n        if (!foundScopeModifier) {\n            // prepend string 'package' to mark default scope.\n            // the package scope modifier is placed at the beginning to conform\n            // with modifiers order as suggested in sections 8.1.1, 8.3.1 and 8.4.3 of the JLS\n            collectedModifiers.add(0, \"package\");\n        }\n\n        return String.join(\" \", collectedModifiers);\n    }", ["What if we are in an interface?"]], ["    private Optional<Collector> ensureCollector(String collectorName,\n                                                String serviceType,\n                                                String nodeOperatingSystem,\n                                                String executablePath,\n                                                String executeParameters,\n                                                String validationCommand,\n                                                String defaultTemplate) {\n\n        this.updatedMigrationState = updatedMigrationState.withNewDefaultTemplate(defaultTemplate);\n\n        Collector collector = null;\n        try {\n            collector = collectorService.findByNameAndOs(collectorName, nodeOperatingSystem);\n            if (collector == null) {\n                final String msg = \"Couldn't find collector '{} on {}' fixing it.\";\n                LOG.debug(msg, collectorName, nodeOperatingSystem);\n                throw new IllegalArgumentException();\n            }\n            if (!defaultTemplate.equals(collector.defaultTemplate()) &&\n                    migrationState.isKnownDefaultTemplate(collector.defaultTemplate())) {\n                LOG.info(\"{} collector default template on {} is unchanged, updating it.\", collectorName, nodeOperatingSystem);\n                try {\n                    return Optional.of(collectorService.save(\n                            collector.toBuilder()\n                                    .defaultTemplate(defaultTemplate)\n                                    .build()));\n                } catch (Exception e) {\n                    LOG.error(\"Can't save collector '{}'!\", collectorName, e);\n                }\n            }\n        } catch (IllegalArgumentException ignored) {\n            LOG.info(\"{} collector on {} is missing, adding it.\", collectorName, nodeOperatingSystem);\n            try {\n                return Optional.of(collectorService.save(Collector.create(\n                        null,\n                        collectorName,\n                        serviceType,\n                        nodeOperatingSystem,\n                        executablePath,\n                        executeParameters,\n                        validationCommand,\n                        defaultTemplate\n                )));\n            } catch (Exception e) {\n                LOG.error(\"Can't save collector '{}'!\", collectorName, e);\n            }\n        }\n\n        if (collector == null) {\n            LOG.error(\"Unable to access fixed '{}' collector!\", collectorName);\n            return Optional.empty();\n        }\n\n\n        return Optional.of(collector);\n    }", ["Wondering if we should pass identifying information here, to be stored with the CRCs. E.g. `collectorName`, `serviceType`, `nodeOperatingSystem`; or even just the current date. It would be tedious to debug a problem with updating, if you only have  an unordered bunch of CRCs to work with."]], ["    private void ensureFilebeatCollectorsAndConfig() {\n\n        StringBuilder filebeatConfigBuilder = new StringBuilder(f(\"\"\"\n                        %s\n                        output.logstash:\n                          hosts: [\"${user.graylog_host}:5044\"]\n                        path:\n                          data: ${sidecar.spoolDir!\\\"/var/lib/graylog-sidecar/collectors/filebeat\\\"}/data\n                          logs: ${sidecar.spoolDir!\\\"/var/lib/graylog-sidecar/collectors/filebeat\\\"}/log\n                        filebeat.inputs:\n                        \"\"\",\n                BEATS_PREAMBEL));\n\n        String apacheConfigType = \"\"\"\n                    - type: filestream\n                      id: apache-filestream\n                      enabled: true\n                      %s\n                      fields_under_root: true\n                      fields:\n                          event_source_product: apache_httpd\"\"\";\n\n        ensureFilebeatCollector(OS_LINUX, \"/usr/lib/graylog-sidecar/filebeat\", filebeatConfigBuilder\n                .append(\"\"\"\n\n                        - type: filestream\n                          id: snort-filestream\n                          enabled: true\n                          paths:\n                            - /var/log/snort/alert_json.txt\n                            - /var/log/snort/appid-output.json\n                          parsers:\n                            - ndjson:\n                                target: \"snort3\"\n                                add_error_key: true\n                                overwrite_keys: true\n                          fields:\n                            event_source_product: snort3\n                        \"\"\")\n                .append(\"\"\"\n\n                        - type: filestream\n                          id: zeek-filestream\n                          enabled: true\n                          paths:\n                            - /opt/zeek/logs/current\n                          parsers:\n                            - ndjson:\n                                target: \"zeek\"\n                                add_error_key: true\n                                overwrite_keys: true\n                          fields:\n                            event_source_product: zeek\n                        \"\"\")\n                .append(f(apacheConfigType, \"\"\"\n                        paths:\n                          - /var/log/apache2/access.log\n                          - /var/log/apache2/error.log\n                          - /var/log/httpd/access_log\n                          - /var/log/httpd/error_log\n                        \"\"\"))\n                .toString()\n        ).ifPresent(collectorState -> ensureDefaultConfiguration(\"filebeat-linux-default\", collectorState));\n\n        ensureFilebeatCollector(OS_FREEBSD, \"/usr/share/filebeat/bin/filebeat\", filebeatConfigBuilder\n                .append(f(apacheConfigType, \"\"\"\n                        paths:\n                          - /var/log/httpd-access.log\n                          - /var/log/httpd-error.log\n                        \"\"\"))\n                .toString()\n        ).ifPresent(collectorState -> ensureDefaultConfiguration(\"filebeat-freebsd-default\", collectorState));\n\n        ensureFilebeatCollector(OS_DARWIN, \"/usr/share/filebeat/bin/filebeat\", filebeatConfigBuilder\n                .append(f(apacheConfigType, \"\"\"\n                        paths:\n                          - /etc/httpd/log/access_log\n                          - /etc/httpd/log/error_log\n                        \"\"\"))\n                .toString()\n        ).ifPresent(collectorState -> ensureDefaultConfiguration(\"filebeat-darwin-default\", collectorState));\n    }", ["```suggestion\r\n                          logs: ${sidecar.spoolDir!\\\"/var/lib/graylog-sidecar/collectors/filebeat\\\"}/log\r\n                          \r\n```\r\nSince we are touching that anyway, can we add a newline here? \r\nThe grouping is nicer this way."]], ["    private void ensureDefaultConfiguration(String name, CollectorState collectorState) {\n        Configuration config = null;\n        try {\n            config = configurationService.findByName(name);\n            if (config == null) {\n                LOG.debug(\"Couldn't find sidecar default configuration'{}' fixing it.\", name);\n                throw new IllegalArgumentException();\n            } else {\n                if (collectorState.updatedTemplate && !config.template().equals(collectorState.collector.defaultTemplate())) {\n                    try {\n                        LOG.info(\"Updating sidecar default configuration template '{}'.\", name);\n                        config = configurationService.save(Configuration.create(\n                                config.id(),\n                                config.collectorId(),\n                                config.name(),\n                                config.color(),\n                                collectorState.collector.defaultTemplate(),\n                                config.tags()));\n                    } catch (Exception e) {\n                        LOG.error(\"Can't update sidecar default configuration '{}'!\", name, e);\n                    }\n                }\n            }\n        } catch (IllegalArgumentException ignored) {\n            LOG.info(\"'{}' sidecar default configuration is missing, adding it.\", name);\n            try {\n                config = configurationService.save(Configuration.createWithoutId(\n                        collectorState.collector.id(),\n                        name,\n                        \"#ffffff\",\n                        collectorState.collector.defaultTemplate(),\n                        Set.of(\"default\")));\n            } catch (Exception e) {\n                LOG.error(\"Can't save sidecar default configuration '{}'!\", name, e);\n            }\n        }\n\n        if (config == null) {\n            LOG.error(\"Unable to access '{}' sidecar default configuration!\", name);\n        }\n    }", ["yeah, we cannot do that. we need to compare that against the known checksums to make sure it wasn't modified", "> This would only fail if you had changed your default config, but not updated your collector. Seems fairly unlikely.\r\n\r\nI think not. Actually this is the easiest way for the user to get things running.\r\nAnd even if it's unlikely, we need to be sure.\r\nSo yeah, we need to check the checksum against the default config.\r\nCan't we make a static version of  Collector#defaultTemplateUnchanged() that accepts a template as an argument?\r\nWe could use that one for the collector and the config then..\r\n", "In hindsight, I think we should've never stored the checksum in the collector itself, but in a migration specific entry in the cluster collection.\r\nWe could keep a list of all known checksums there. it would be accessible for collectors and configs alike.", "@patrickmann  How about this instead?\r\nhttps://github.com/Graylog2/graylog2-server/pull/17624"]], ["    private Optional<CollectorState> ensureCollector(String collectorName,\n                                                     String serviceType,\n                                                     String nodeOperatingSystem,\n                                                     String executablePath,\n                                                     String executeParameters,\n                                                     String validationCommand,\n                                                     String defaultTemplate) {\n        Collector collector = null;\n        try {\n            collector = collectorService.findByNameAndOs(collectorName, nodeOperatingSystem);\n            if (collector == null) {\n                final String msg = \"Couldn't find collector '{} on {}' fixing it.\";\n                LOG.debug(msg, collectorName, nodeOperatingSystem);\n                throw new IllegalArgumentException();\n            }\n\n            if (collector.defaultTemplateUnchanged()) {\n                long oldCRC = collector.defaultTemplateCRC();\n                long newCRC = Collector.checksum(defaultTemplate.getBytes(StandardCharsets.UTF_8));\n                if (collector.defaultTemplateCRC() == null      // known obsolete version of template\n                        || newCRC != oldCRC // new standard template\n                ) {\n                    LOG.info(\"{} collector default template on {} is unchanged, updating it.\", collectorName, nodeOperatingSystem);\n                    try {\n                        return Optional.of(new CollectorState(\n                                collectorService.save(\n                                        collector.toBuilder()\n                                                .defaultTemplate(defaultTemplate)\n                                                .defaultTemplateCRC(newCRC)\n                                                .build()),\n                                oldCRC));\n                    } catch (Exception e) {\n                        LOG.error(\"Can't save collector '{}'!\", collectorName, e);\n                    }\n                }\n            }\n        } catch (IllegalArgumentException ignored) {\n            LOG.info(\"{} collector on {} is missing, adding it.\", collectorName, nodeOperatingSystem);\n            try {\n                long newCRC = Collector.checksum(defaultTemplate.getBytes(StandardCharsets.UTF_8));\n                return Optional.of(new CollectorState(\n                        collectorService.save(Collector.create(\n                                null,\n                                collectorName,\n                                serviceType,\n                                nodeOperatingSystem,\n                                executablePath,\n                                executeParameters,\n                                validationCommand,\n                                defaultTemplate,\n                                newCRC)),\n                        null));\n            } catch (Exception e) {\n                LOG.error(\"Can't save collector '{}'!\", collectorName, e);\n            }\n        }\n\n        if (collector == null) {\n            LOG.error(\"Unable to access fixed '{}' collector!\", collectorName);\n            return Optional.empty();\n        }\n\n        return Optional.of(new CollectorState(collector, collector.defaultTemplateCRC()));\n    }", ["```suggestion\r\n                Long oldCRC = collector.defaultTemplateCRC();\r\n```\r\nThis will create a NPE on upgrades from before 5.2. IntelliJ even warns about this!"]], ["    private Optional<CollectorState> ensureCollector(String collectorName,\n                                                     String serviceType,\n                                                     String nodeOperatingSystem,\n                                                     String executablePath,\n                                                     String executeParameters,\n                                                     String validationCommand,\n                                                     String defaultTemplate) {\n        Collector collector = null;\n        try {\n            collector = collectorService.findByNameAndOs(collectorName, nodeOperatingSystem);\n            if (collector == null) {\n                final String msg = \"Couldn't find collector '{} on {}' fixing it.\";\n                LOG.debug(msg, collectorName, nodeOperatingSystem);\n                throw new IllegalArgumentException();\n            }\n\n            if (collector.defaultTemplateUnchanged()) {\n                long oldCRC = collector.defaultTemplateCRC();\n                long newCRC = Collector.checksum(defaultTemplate.getBytes(StandardCharsets.UTF_8));\n                if (collector.defaultTemplateCRC() == null      // known obsolete version of template\n                        || newCRC != oldCRC // new standard template\n                ) {\n                    LOG.info(\"{} collector default template on {} is unchanged, updating it.\", collectorName, nodeOperatingSystem);\n                    try {\n                        return Optional.of(new CollectorState(\n                                collectorService.save(\n                                        collector.toBuilder()\n                                                .defaultTemplate(defaultTemplate)\n                                                .defaultTemplateCRC(newCRC)\n                                                .build()),\n                                oldCRC));\n                    } catch (Exception e) {\n                        LOG.error(\"Can't save collector '{}'!\", collectorName, e);\n                    }\n                }\n            }\n        } catch (IllegalArgumentException ignored) {\n            LOG.info(\"{} collector on {} is missing, adding it.\", collectorName, nodeOperatingSystem);\n            try {\n                long newCRC = Collector.checksum(defaultTemplate.getBytes(StandardCharsets.UTF_8));\n                return Optional.of(new CollectorState(\n                        collectorService.save(Collector.create(\n                                null,\n                                collectorName,\n                                serviceType,\n                                nodeOperatingSystem,\n                                executablePath,\n                                executeParameters,\n                                validationCommand,\n                                defaultTemplate,\n                                newCRC)),\n                        null));\n            } catch (Exception e) {\n                LOG.error(\"Can't save collector '{}'!\", collectorName, e);\n            }\n        }\n\n        if (collector == null) {\n            LOG.error(\"Unable to access fixed '{}' collector!\", collectorName);\n            return Optional.empty();\n        }\n\n        return Optional.of(new CollectorState(collector, collector.defaultTemplateCRC()));\n    }", ["```suggestion\r\n                        || !Objects.equals(newCRC, oldCRC) // new standard template\r\n```\r\navoid NPE"]], ["    public String toString()\n    {\n        return \"PendingSetupMessageFromSource{\" +\n            \"sessionId=\" + sessionId +\n            \", streamId=\" + streamId +\n            \", transportIndex=\" + transportIndex +\n            \", periodic=\" + periodic +\n            \", channelEndpoint=\" + channelEndpoint +\n            \", controlAddress=\" + controlAddress +\n            \", timeOfStatusMessageNs=\" + timeOfStatusMessageNs +\n            '}';\n    }", ["## Use of default toString()\n\nDefault toString(): ReceiveChannelEndpoint inherits toString() from Object, and so is not suitable for printing.\n\n[Show more details](https://github.com/real-logic/aeron/security/code-scanning/2520)"]], ["    public ChannelUriStringBuilder responseCorrelationId(final ChannelUri channelUri)\n    {\n        final String responseCorrelationIdString = channelUri.get(RESPONSE_CORRELATION_ID_PARAM_NAME);\n\n        if (null != responseCorrelationIdString)\n        {\n            responseCorrelationId(Long.valueOf(responseCorrelationIdString));\n        }\n\n        return this;\n    }", ["## Missing catch of NumberFormatException\n\nPotential uncaught 'java.lang.NumberFormatException'.\n\n[Show more details](https://github.com/real-logic/aeron/security/code-scanning/2521)"]], ["    public int doWork()\n    {\n        int workCount = 0;\n\n        if (null == serverSubscription)\n        {\n            serverSubscription = aeron.addSubscription(\n                requestUriBuilder.build(),\n                requestStreamId,\n                availableImages::offer,\n                unavailableImages::offer);\n            workCount++;\n        }\n\n        Image image;\n        while (null != (image = availableImages.poll()))\n        {\n            workCount++;\n            getOrCreateSession(image);\n        }\n\n        while (null != (image = unavailableImages.poll()))\n        {\n            workCount++;\n            clientToPublicationMap.remove(image.correlationId());\n        }\n\n        workCount += serverSubscription.poll(\n            (buffer, offset, length, header) ->\n            {\n                final ResponseSession session = getOrCreateSession(\n                    serverSubscription.imageBySessionId(header.sessionId()));\n\n                session.process(buffer, offset, length, header);\n            },\n            1);\n\n\n        return workCount;\n    }", ["## Ignored error status of call\n\nMethod onAvailableImage ignores exceptional return value of OneToOneConcurrentArrayQueue.offer.\n\n[Show more details](https://github.com/real-logic/aeron/security/code-scanning/2522)"]], ["    public int doWork()\n    {\n        int workCount = 0;\n\n        if (null == serverSubscription)\n        {\n            serverSubscription = aeron.addSubscription(\n                requestUriBuilder.build(),\n                requestStreamId,\n                availableImages::offer,\n                unavailableImages::offer);\n            workCount++;\n        }\n\n        Image image;\n        while (null != (image = availableImages.poll()))\n        {\n            workCount++;\n            getOrCreateSession(image);\n        }\n\n        while (null != (image = unavailableImages.poll()))\n        {\n            workCount++;\n            clientToPublicationMap.remove(image.correlationId());\n        }\n\n        workCount += serverSubscription.poll(\n            (buffer, offset, length, header) ->\n            {\n                final ResponseSession session = getOrCreateSession(\n                    serverSubscription.imageBySessionId(header.sessionId()));\n\n                session.process(buffer, offset, length, header);\n            },\n            1);\n\n\n        return workCount;\n    }", ["## Ignored error status of call\n\nMethod onUnavailableImage ignores exceptional return value of OneToOneConcurrentArrayQueue.offer.\n\n[Show more details](https://github.com/real-logic/aeron/security/code-scanning/2523)"]], ["    @Test\n    public void\n    basic_auth_request_post_processor_works() throws Exception {\n        RestAssuredMockMvc.given().\n                mockMvc(mvc).\n                auth().with(httpBasic(\"username\", \"password\")).\n                param(\"name\", \"Johan\").\n                when().\n                get(\"/secured/greeting\").\n                then().\n                statusCode(200).\n                body(\"content\", equalTo(\"Hello, Johan!\")).\n                expect(authenticated().withUsername(\"username\"));\n    }", ["I think it is generally a good idea to respect whatever formatting conventions the repository has adopted. We are just guests here and so we should not tell the host to re-organize his cupboard because we are like it differently. \r\n\r\nIt would also be much easier to review without the formatting changes."]], ["    public ModValidator discoverMods() {\n        LOGGER.debug(LogMarkers.SCAN,\"Scanning for mods and other resources to load. We know {} ways to find mods\", modLocatorList.size());\n        List<ModFile> loadedFiles = new ArrayList<>();\n        List<EarlyLoadingException.ExceptionData> discoveryErrorData = new ArrayList<>();\n        boolean successfullyLoadedMods = true;\n        List<IModFileInfo> brokenFiles = new ArrayList<>();\n        var dist = FMLLoader.getDist();\n        ImmediateWindowHandler.updateProgress(\"Discovering mod files\");\n        //Loop all mod locators to get the prime mods to load from.\n        for (IModLocator locator : modLocatorList) {\n            try {\n                LOGGER.debug(LogMarkers.SCAN, \"Trying locator {}\", locator);\n                var candidates = locator.scanMods();\n                LOGGER.debug(LogMarkers.SCAN, \"Locator {} found {} candidates or errors\", locator, candidates.size());\n                var exceptions = candidates.stream().map(IModLocator.ModFileOrException::ex).filter(Objects::nonNull).toList();\n                if (!exceptions.isEmpty()) {\n                    LOGGER.debug(LogMarkers.SCAN, \"Locator {} found {} invalid mod files\", locator, exceptions.size());\n                    brokenFiles.addAll(exceptions.stream().map(e->e instanceof InvalidModFileException ime ? ime.getBrokenFile() : null).filter(Objects::nonNull).toList());\n                }\n                var locatedFiles = candidates.stream().map(IModLocator.ModFileOrException::file).filter(Objects::nonNull).collect(Collectors.toList());\n\n                var badModFiles = locatedFiles.stream().filter(file -> !(file instanceof ModFile)).toList();\n                if (!badModFiles.isEmpty()) {\n                    LOGGER.error(LogMarkers.SCAN, \"Locator {} returned {} files which is are not ModFile instances! They will be skipped!\", locator, badModFiles.size());\n                    brokenFiles.addAll(badModFiles.stream().map(IModFile::getModFileInfo).toList());\n                    locatedFiles.removeAll(badModFiles);\n                }\n\n                if (dist.isDedicatedServer()) {\n                    var clientOnlyModFiles = locatedFiles.stream().filter(file -> file.getModFileInfo().isClientSideOnly()).toList();\n                    if (!clientOnlyModFiles.isEmpty()) {\n                        LOGGER.debug(LogMarkers.SCAN, \"Locator {} returned {} files which are client-side-only mods, but we're on a dedicated server. They will be skipped!\", locator, clientOnlyModFiles.size());\n                        locatedFiles.removeAll(clientOnlyModFiles);\n                    }\n                }\n\n                LOGGER.debug(LogMarkers.SCAN, \"Locator {} found {} valid mod files\", locator, locatedFiles.size());\n                handleLocatedFiles(loadedFiles, locatedFiles);\n            } catch (InvalidModFileException imfe) {\n                // We don't generally expect this exception, since it should come from the candidates stream above and be handled in the Locator, but just in case.\n                LOGGER.error(LogMarkers.SCAN, \"Locator {} found an invalid mod file {}\", locator, imfe.getBrokenFile(), imfe);\n                brokenFiles.add(imfe.getBrokenFile());\n            } catch (EarlyLoadingException exception) {\n                LOGGER.error(LogMarkers.SCAN, \"Failed to load mods with locator {}\", locator, exception);\n                discoveryErrorData.addAll(exception.getAllData());\n            }\n        }\n\n        //First processing run of the mod list. Any duplicates will cause resolution failure and dependency loading will be skipped.\n        Map<IModFile.Type, List<ModFile>> modFilesMap = Maps.newHashMap();\n        try {\n            final UniqueModListBuilder modsUniqueListBuilder = new UniqueModListBuilder(loadedFiles);\n            final UniqueModListBuilder.UniqueModListData uniqueModsData = modsUniqueListBuilder.buildUniqueList();\n\n            //Grab the temporary results.\n            //This allows loading to continue to a base state, in case dependency loading fails.\n            modFilesMap = uniqueModsData.modFiles().stream()\n                            .collect(Collectors.groupingBy(IModFile::getType));\n            loadedFiles = uniqueModsData.modFiles();\n        }\n        catch (EarlyLoadingException exception) {\n            LOGGER.error(LogMarkers.SCAN, \"Failed to build unique mod list after mod discovery.\", exception);\n            discoveryErrorData.addAll(exception.getAllData());\n            successfullyLoadedMods = false;\n        }\n\n        //We can continue loading if prime mods loaded successfully.\n        if (successfullyLoadedMods) {\n            LOGGER.debug(LogMarkers.SCAN, \"Successfully Loaded {} mods. Attempting to load dependencies...\", loadedFiles.size());\n            for (IDependencyLocator locator : dependencyLocatorList) {\n                try {\n                    LOGGER.debug(LogMarkers.SCAN,\"Trying locator {}\", locator);\n                    final List<IModFile> locatedMods = ImmutableList.copyOf(loadedFiles);\n\n                    var locatedFiles = locator.scanMods(locatedMods);\n                    if (locatedFiles.stream().anyMatch(file -> !(file instanceof ModFile))) {\n                        LOGGER.error(LogMarkers.SCAN, \"A dependency locator returned a file which is not a ModFile instance!. They will be skipped!\");\n                    }\n\n                    handleLocatedFiles(loadedFiles, locatedFiles);\n                }\n                catch (EarlyLoadingException exception) {\n                    LOGGER.error(LogMarkers.SCAN, \"Failed to load dependencies with locator {}\", locator, exception);\n                    discoveryErrorData.addAll(exception.getAllData());\n                }\n            }\n\n            //Second processing run of the mod list. Any duplicates will cause resolution failure and only the mods list will be loaded.\n            try {\n                final UniqueModListBuilder modsAndDependenciesUniqueListBuilder = new UniqueModListBuilder(loadedFiles);\n                final UniqueModListBuilder.UniqueModListData uniqueModsAndDependenciesData = modsAndDependenciesUniqueListBuilder.buildUniqueList();\n\n                //We now only need the mod files map, not the list.\n                modFilesMap = uniqueModsAndDependenciesData.modFiles().stream()\n                                .collect(Collectors.groupingBy(IModFile::getType));\n            } catch (EarlyLoadingException exception) {\n                LOGGER.error(LogMarkers.SCAN, \"Failed to build unique mod list after dependency discovery.\", exception);\n                discoveryErrorData.addAll(exception.getAllData());\n                modFilesMap = loadedFiles.stream().collect(Collectors.groupingBy(IModFile::getType));\n            }\n        }\n        else {\n            //Failure notify the listeners.\n            LOGGER.error(LogMarkers.SCAN, \"Mod Discovery failed. Skipping dependency discovery.\");\n        }\n\n        //Validate the loading. With a deduplicated list, we can now successfully process the artifacts and load\n        //transformer plugins.\n        var validator = new ModValidator(modFilesMap, brokenFiles, discoveryErrorData);\n        validator.stage1Validation();\n        return validator;\n    }", ["Should we consider making this a warning message instead? Servers should not be attempting to load client-only mods on dedicated server anyway."]], ["    @SuppressWarnings(\"unchecked\")\n    public static <T, W> void addWrappedListener(Class<T> type, Class<W> wrappedClass, BiConsumer<AttachCapabilitiesEvent<T>, W> eventConsumer)\n    {\n        if (!Item.class.isAssignableFrom(type)) throw new IllegalStateException(\"Unable to add Listener for Items. Use CapabilitySystem.addListener(Class, Consumer) for non Item related stuff\");\n        LISTENER_LIST.computeIfAbsent(type, (e) -> new ArrayList<>()).add((cls) -> {\n            eventConsumer.accept((AttachCapabilitiesEvent<T>) cls, (W) cls.getObject());\n        });\n    }", ["I don't remember if lambda brackets also go on new line. @LexManos?"]], ["    public List<IForgeGlslPreprocessor> getPreprocessors()\n    {\n        return List.copyOf(preprocessors);\n    }", ["Is there a reason this returns a copy of the list as opposed to say just a view of the underlying list?"]], ["    public void newProcessor(IForgeGlslPreprocessor preprocessor)\n    {\n        preprocessors.add(preprocessor);\n    }", ["Not sure about what use cases people have so the answer may just be \"no\", but would it be useful to people for this to be vararg?"]], ["    public void newImportHandler(final String importPrefix, final IShaderImportHandler importHandler) {\n        preprocessors.add(new GlslPreprocessor(importPrefix)\n        {\n            @org.jetbrains.annotations.Nullable\n            @Override\n            public String applyImport(boolean isRelative, @NotNull String toImport)\n            {\n                return importHandler.apply(isRelative, toImport);\n            }\n        });\n    }", ["No need for the annotation to use a FQN this isn't a patch file"]], ["    public static void renderBuffer(RenderType renderType, BufferBuilder.RenderedBuffer buffer)\n    {\n        OITLevelRenderer.getInstance().checkHandlesThenQueueOrRender(renderType, buffer);\n    }", ["Some of these hooks almost feel redundant and like the `OITLevelRenderer` is the actual hook location anyway, is there a reason that simple bouncers aren't just inlined to have the targets call `net.minecraftforge.client.renderer.transparency.OITLevelRenderer.getInstance()` instead of `net.minecraftforge.client.ForgeHooksClient`? Is it just future proofing for if forge adds more level renderer replacements so that then they can basically be replaced with switch statement calling the corresponding proper one?"]], ["    public static void afterShaderAttachment(Shader shader)\n    {\n        if (!(shader instanceof ShaderInstance shaderInstance))\n            return;\n\n        ModLoader.get().postEvent(new ShaderEvent.OnAttachmentInitialization(shaderInstance));\n    }", ["Given this is a one liner anyway rather than inverting the instance check and then returning just do the instance check and call the one line event posting"]], ["\tpublic LivingEatEvent(@javax.annotation.Nullable LivingEntity entity, int foodAmount, float saturationAmount) {\n\t\tsuper(entity);\n\t\tthis.foodAmount = foodAmount;\n\t\tthis.saturaionAmount = saturationAmount;\n\t}", ["Starting bracket on new line for entire file."]], ["\tpublic LivingEatEvent(@javax.annotation.Nullable LivingEntity entity, ItemStack foodItem, FoodProperties prop) {\n\t\tthis(entity, prop.getNutrition(), prop.getSaturationModifier());\n\t\tthis.foodItem = foodItem;\n\t}", ["What is the point of making these the same event if not all properties are available when eating?"]], ["\tpublic ItemStack getFoodItem() {\n\t\treturn foodItem;\n\t}", ["Document"]], ["\tpublic LivingEatEvent(@javax.annotation.Nullable LivingEntity entity, int foodAmount, float saturationAmount) {\n\t\tsuper(entity);\n\t\tthis.foodAmount = foodAmount;\n\t\tthis.saturaionAmount = saturationAmount;\n\t}", ["Use jetbrains nullable."]], ["\tpublic LivingFoodEffectEvent(LivingEntity entity, ItemStack foodItem) {\n\t\tsuper(entity);\n\t\tthis.foodItem = foodItem;\n\t\teffectPairs = foodItem.getFoodProperties(entity).getEffects();\n\t}", ["New line braces for entire file."]], ["\tpublic List<Pair<MobEffectInstance, Float>> getEffects() {\n\t\treturn effectPairs;\n\t}", ["Document."]], ["    public record ModelSettings(@NotNull ResourceLocation modelLocation,\n                                boolean automaticCulling, boolean shadeQuads, boolean flipV,\n                                boolean emissiveAmbient, @Nullable String mtlOverride, boolean allowHomonymObjectName)\n    { }", ["This is a breaking change because any callers to the previous constructor (without the new parameter) will break. \r\n\r\nPlease add a new constructor to this record which calls the canonical constructor with an appropriate default value for the new parameter, mark that new constructor as deprecated for removal (`@Deprecated(forRemoval = true, since = \"1.19.2\")`, and add a javadoc with a `@deprecated` tag directing users to the canonical constructor (which has the new parameter)."]], ["    static ObjModel parse(ObjTokenizer tokenizer, ModelSettings settings, Map<String, String> deprecationWarnings) throws IOException\n    {\n        var modelLocation = settings.modelLocation;\n        var materialLibraryOverrideLocation = settings.mtlOverride;\n        var allowHomonymObjectName = settings.allowHomonymObjectName;\n        var hasHomonymObjectNameAppeared = false;\n        var model = new ObjModel(settings, deprecationWarnings);\n\n        // for relative references to material libraries\n        String modelDomain = modelLocation.getNamespace();\n        String modelPath = modelLocation.getPath();\n        int lastSlash = modelPath.lastIndexOf('/');\n        if (lastSlash >= 0)\n            modelPath = modelPath.substring(0, lastSlash + 1); // include the '/'\n        else\n            modelPath = \"\";\n\n        ObjMaterialLibrary mtllib = ObjMaterialLibrary.EMPTY;\n        ObjMaterialLibrary.Material currentMat = null;\n        String currentSmoothingGroup = null;\n        ModelGroup currentGroup = null;\n        ModelObject currentObject = null;\n        ModelMesh currentMesh = null;\n\n        boolean objAboveGroup = false;\n\n        if (materialLibraryOverrideLocation != null)\n        {\n            String lib = materialLibraryOverrideLocation;\n            if (lib.contains(\":\"))\n                mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(lib));\n            else\n                mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(modelDomain, modelPath + lib));\n        }\n\n        String[] line;\n        while ((line = tokenizer.readAndSplitLine(true)) != null)\n        {\n            switch (line[0])\n            {\n                case \"mtllib\": // Loads material library\n                {\n                    if (materialLibraryOverrideLocation != null)\n                        break;\n\n                    String lib = line[1];\n                    if (lib.contains(\":\"))\n                        mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(lib));\n                    else\n                        mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(modelDomain, modelPath + lib));\n                    break;\n                }\n\n                case \"usemtl\": // Sets the current material (starts new mesh)\n                {\n                    String mat = Strings.join(Arrays.copyOfRange(line, 1, line.length), \" \");\n                    ObjMaterialLibrary.Material newMat = mtllib.getMaterial(mat);\n                    if (!Objects.equals(newMat, currentMat))\n                    {\n                        currentMat = newMat;\n                        if (currentMesh != null && currentMesh.mat == null && currentMesh.faces.size() == 0)\n                        {\n                            currentMesh.mat = currentMat;\n                        }\n                        else\n                        {\n                            // Start new mesh\n                            currentMesh = null;\n                        }\n                    }\n                    break;\n                }\n\n                case \"v\": // Vertex\n                    model.positions.add(parseVector4To3(line));\n                    break;\n                case \"vt\": // Vertex texcoord\n                    model.texCoords.add(parseVector2(line));\n                    break;\n                case \"vn\": // Vertex normal\n                    model.normals.add(parseVector3(line));\n                    break;\n                case \"vc\": // Vertex color (non-standard)\n                    model.colors.add(parseVector4(line));\n                    break;\n\n                case \"f\": // Face\n                {\n                    if (currentMesh == null)\n                    {\n                        currentMesh = model.new ModelMesh(currentMat, currentSmoothingGroup);\n                        if (currentObject != null)\n                        {\n                            currentObject.meshes.add(currentMesh);\n                        }\n                        else\n                        {\n                            if (currentGroup == null)\n                            {\n                                currentGroup = model.new ModelGroup(\"\");\n                                model.parts.put(\"\", currentGroup);\n                            }\n                            currentGroup.meshes.add(currentMesh);\n                        }\n                    }\n\n                    int[][] vertices = new int[line.length - 1][];\n                    for (int i = 0; i < vertices.length; i++)\n                    {\n                        String vertexData = line[i + 1];\n                        String[] vertexParts = vertexData.split(\"/\");\n                        int[] vertex = Arrays.stream(vertexParts).mapToInt(num -> Strings.isNullOrEmpty(num) ? 0 : Integer.parseInt(num)).toArray();\n                        if (vertex[0] < 0) vertex[0] = model.positions.size() + vertex[0];\n                        else vertex[0]--;\n                        if (vertex.length > 1)\n                        {\n                            if (vertex[1] < 0) vertex[1] = model.texCoords.size() + vertex[1];\n                            else vertex[1]--;\n                            if (vertex.length > 2)\n                            {\n                                if (vertex[2] < 0) vertex[2] = model.normals.size() + vertex[2];\n                                else vertex[2]--;\n                                if (vertex.length > 3)\n                                {\n                                    if (vertex[3] < 0) vertex[3] = model.colors.size() + vertex[3];\n                                    else vertex[3]--;\n                                }\n                            }\n                        }\n                        vertices[i] = vertex;\n                    }\n\n                    currentMesh.faces.add(vertices);\n\n                    break;\n                }\n\n                case \"s\": // Smoothing group (starts new mesh)\n                {\n                    String smoothingGroup = \"off\".equals(line[1]) ? null : line[1];\n                    if (!Objects.equals(currentSmoothingGroup, smoothingGroup))\n                    {\n                        currentSmoothingGroup = smoothingGroup;\n                        if (currentMesh != null && currentMesh.smoothingGroup == null && currentMesh.faces.size() == 0)\n                        {\n                            currentMesh.smoothingGroup = currentSmoothingGroup;\n                        }\n                        else\n                        {\n                            // Start new mesh\n                            currentMesh = null;\n                        }\n                    }\n                    break;\n                }\n\n                case \"g\":\n                {\n                    String name = line[1];\n                    if (objAboveGroup)\n                    {\n                        currentObject = model.new ModelObject(currentGroup.name() + \"/\" + name);\n                        currentGroup.parts.put(name, currentObject);\n                    }\n                    else\n                    {\n                        currentGroup = model.new ModelGroup(name);\n                        model.parts.put(name, currentGroup);\n                        currentObject = null;\n                    }\n                    // Start new mesh\n                    currentMesh = null;\n                    break;\n                }\n\n                case \"o\":\n                {\n                    String name = line[1];\n                    if (model.parts.containsKey(name))\n                    {\n                        hasHomonymObjectNameAppeared = true;\n                        if (allowHomonymObjectName)\n                        {\n                            int suffixNum = 0;\n                            String renamed;\n                            do\n                            {\n                                renamed = name + '_' + (suffixNum++);\n                            }\n                            while (model.parts.containsKey(renamed));\n                            name = renamed;\n                        }\n                    }\n                    if (objAboveGroup || currentGroup == null)\n                    {\n                        objAboveGroup = true;\n\n                        currentGroup = model.new ModelGroup(name);\n                        model.parts.put(name, currentGroup);\n                        currentObject = null;\n                    }\n                    else\n                    {\n                        currentObject = model.new ModelObject(currentGroup.name() + \"/\" + name);\n                        currentGroup.parts.put(name, currentObject);\n                    }\n                    // Start new mesh\n                    currentMesh = null;\n                    break;\n                }\n            }\n        }\n        if (!allowHomonymObjectName && hasHomonymObjectNameAppeared)\n        {\n            LOGGER.error(\"find homonym object in obj model:\" + settings.modelLocation + \", use allow_homonym_object_name=true can rename them for you\");\n        }\n        return model;\n    }", ["Some error message cleanup, as well as using logger parameter substitution instead of manual string concatenation:\r\n```suggestion\r\n            LOGGER.error(\"Found homonym object in ObjModel: {}; use the 'allow_homonym_object_name' option to automatically resolve homonyms\", settings.modelLocation);\r\n```"]], ["    static ObjModel parse(ObjTokenizer tokenizer, ModelSettings settings, Map<String, String> deprecationWarnings) throws IOException\n    {\n        var modelLocation = settings.modelLocation;\n        var materialLibraryOverrideLocation = settings.mtlOverride;\n        var allowHomonymObjectName = settings.allowHomonymObjectName;\n        var hasHomonymObjectNameAppeared = false;\n        var model = new ObjModel(settings, deprecationWarnings);\n\n        // for relative references to material libraries\n        String modelDomain = modelLocation.getNamespace();\n        String modelPath = modelLocation.getPath();\n        int lastSlash = modelPath.lastIndexOf('/');\n        if (lastSlash >= 0)\n            modelPath = modelPath.substring(0, lastSlash + 1); // include the '/'\n        else\n            modelPath = \"\";\n\n        ObjMaterialLibrary mtllib = ObjMaterialLibrary.EMPTY;\n        ObjMaterialLibrary.Material currentMat = null;\n        String currentSmoothingGroup = null;\n        ModelGroup currentGroup = null;\n        ModelObject currentObject = null;\n        ModelMesh currentMesh = null;\n\n        boolean objAboveGroup = false;\n\n        if (materialLibraryOverrideLocation != null)\n        {\n            String lib = materialLibraryOverrideLocation;\n            if (lib.contains(\":\"))\n                mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(lib));\n            else\n                mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(modelDomain, modelPath + lib));\n        }\n\n        String[] line;\n        while ((line = tokenizer.readAndSplitLine(true)) != null)\n        {\n            switch (line[0])\n            {\n                case \"mtllib\": // Loads material library\n                {\n                    if (materialLibraryOverrideLocation != null)\n                        break;\n\n                    String lib = line[1];\n                    if (lib.contains(\":\"))\n                        mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(lib));\n                    else\n                        mtllib = ObjLoader.INSTANCE.loadMaterialLibrary(new ResourceLocation(modelDomain, modelPath + lib));\n                    break;\n                }\n\n                case \"usemtl\": // Sets the current material (starts new mesh)\n                {\n                    String mat = Strings.join(Arrays.copyOfRange(line, 1, line.length), \" \");\n                    ObjMaterialLibrary.Material newMat = mtllib.getMaterial(mat);\n                    if (!Objects.equals(newMat, currentMat))\n                    {\n                        currentMat = newMat;\n                        if (currentMesh != null && currentMesh.mat == null && currentMesh.faces.size() == 0)\n                        {\n                            currentMesh.mat = currentMat;\n                        }\n                        else\n                        {\n                            // Start new mesh\n                            currentMesh = null;\n                        }\n                    }\n                    break;\n                }\n\n                case \"v\": // Vertex\n                    model.positions.add(parseVector4To3(line));\n                    break;\n                case \"vt\": // Vertex texcoord\n                    model.texCoords.add(parseVector2(line));\n                    break;\n                case \"vn\": // Vertex normal\n                    model.normals.add(parseVector3(line));\n                    break;\n                case \"vc\": // Vertex color (non-standard)\n                    model.colors.add(parseVector4(line));\n                    break;\n\n                case \"f\": // Face\n                {\n                    if (currentMesh == null)\n                    {\n                        currentMesh = model.new ModelMesh(currentMat, currentSmoothingGroup);\n                        if (currentObject != null)\n                        {\n                            currentObject.meshes.add(currentMesh);\n                        }\n                        else\n                        {\n                            if (currentGroup == null)\n                            {\n                                currentGroup = model.new ModelGroup(\"\");\n                                model.parts.put(\"\", currentGroup);\n                            }\n                            currentGroup.meshes.add(currentMesh);\n                        }\n                    }\n\n                    int[][] vertices = new int[line.length - 1][];\n                    for (int i = 0; i < vertices.length; i++)\n                    {\n                        String vertexData = line[i + 1];\n                        String[] vertexParts = vertexData.split(\"/\");\n                        int[] vertex = Arrays.stream(vertexParts).mapToInt(num -> Strings.isNullOrEmpty(num) ? 0 : Integer.parseInt(num)).toArray();\n                        if (vertex[0] < 0) vertex[0] = model.positions.size() + vertex[0];\n                        else vertex[0]--;\n                        if (vertex.length > 1)\n                        {\n                            if (vertex[1] < 0) vertex[1] = model.texCoords.size() + vertex[1];\n                            else vertex[1]--;\n                            if (vertex.length > 2)\n                            {\n                                if (vertex[2] < 0) vertex[2] = model.normals.size() + vertex[2];\n                                else vertex[2]--;\n                                if (vertex.length > 3)\n                                {\n                                    if (vertex[3] < 0) vertex[3] = model.colors.size() + vertex[3];\n                                    else vertex[3]--;\n                                }\n                            }\n                        }\n                        vertices[i] = vertex;\n                    }\n\n                    currentMesh.faces.add(vertices);\n\n                    break;\n                }\n\n                case \"s\": // Smoothing group (starts new mesh)\n                {\n                    String smoothingGroup = \"off\".equals(line[1]) ? null : line[1];\n                    if (!Objects.equals(currentSmoothingGroup, smoothingGroup))\n                    {\n                        currentSmoothingGroup = smoothingGroup;\n                        if (currentMesh != null && currentMesh.smoothingGroup == null && currentMesh.faces.size() == 0)\n                        {\n                            currentMesh.smoothingGroup = currentSmoothingGroup;\n                        }\n                        else\n                        {\n                            // Start new mesh\n                            currentMesh = null;\n                        }\n                    }\n                    break;\n                }\n\n                case \"g\":\n                {\n                    String name = line[1];\n                    if (objAboveGroup)\n                    {\n                        currentObject = model.new ModelObject(currentGroup.name() + \"/\" + name);\n                        currentGroup.parts.put(name, currentObject);\n                    }\n                    else\n                    {\n                        currentGroup = model.new ModelGroup(name);\n                        model.parts.put(name, currentGroup);\n                        currentObject = null;\n                    }\n                    // Start new mesh\n                    currentMesh = null;\n                    break;\n                }\n\n                case \"o\":\n                {\n                    String name = line[1];\n                    if (model.parts.containsKey(name))\n                    {\n                        hasHomonymObjectNameAppeared = true;\n                        if (allowHomonymObjectName)\n                        {\n                            int suffixNum = 0;\n                            String renamed;\n                            do\n                            {\n                                renamed = name + '_' + (suffixNum++);\n                            }\n                            while (model.parts.containsKey(renamed));\n                            name = renamed;\n                        }\n                    }\n                    if (objAboveGroup || currentGroup == null)\n                    {\n                        objAboveGroup = true;\n\n                        currentGroup = model.new ModelGroup(name);\n                        model.parts.put(name, currentGroup);\n                        currentObject = null;\n                    }\n                    else\n                    {\n                        currentObject = model.new ModelObject(currentGroup.name() + \"/\" + name);\n                        currentGroup.parts.put(name, currentObject);\n                    }\n                    // Start new mesh\n                    currentMesh = null;\n                    break;\n                }\n            }\n        }\n        if (!allowHomonymObjectName && hasHomonymObjectNameAppeared)\n        {\n            LOGGER.error(\"find homonym object in obj model:\" + settings.modelLocation + \", use allow_homonym_object_name=true can rename them for you\");\n        }\n        return model;\n    }", ["I wonder if we should begin this at 1 instead, so the names would be: `object`, `object_1`, `object_2`."]], ["    @Override\n    public ObjModel read(JsonObject jsonObject, JsonDeserializationContext deserializationContext)\n    {\n        if (!jsonObject.has(\"model\"))\n            throw new JsonParseException(\"OBJ Loader requires a 'model' key that points to a valid .OBJ model.\");\n\n        String modelLocation = jsonObject.get(\"model\").getAsString();\n\n        boolean automaticCulling = GsonHelper.getAsBoolean(jsonObject, \"automatic_culling\", true);\n        boolean shadeQuads = GsonHelper.getAsBoolean(jsonObject, \"shade_quads\", true);\n        boolean flipV = GsonHelper.getAsBoolean(jsonObject, \"flip_v\", false);\n        boolean emissiveAmbient = GsonHelper.getAsBoolean(jsonObject, \"emissive_ambient\", true);\n        String mtlOverride = GsonHelper.getAsString(jsonObject, \"mtl_override\", null);\n        boolean allowHomonymObjectName = GsonHelper.getAsBoolean(jsonObject,\"allow_homonym_object_name\",false);\n\n        // TODO: Deprecated names. To be removed in 1.20\n        var deprecationWarningsBuilder = ImmutableMap.<String, String>builder();\n        if (jsonObject.has(\"detectCullableFaces\"))\n        {\n            automaticCulling = GsonHelper.getAsBoolean(jsonObject, \"detectCullableFaces\");\n            deprecationWarningsBuilder.put(\"detectCullableFaces\", \"automatic_culling\");\n        }\n        if (jsonObject.has(\"diffuseLighting\"))\n        {\n            shadeQuads = GsonHelper.getAsBoolean(jsonObject, \"diffuseLighting\");\n            deprecationWarningsBuilder.put(\"diffuseLighting\", \"shade_quads\");\n        }\n        if (jsonObject.has(\"flip-v\"))\n        {\n            flipV = GsonHelper.getAsBoolean(jsonObject, \"flip-v\");\n            deprecationWarningsBuilder.put(\"flip-v\", \"flip_v\");\n        }\n        if (jsonObject.has(\"ambientToFullbright\"))\n        {\n            emissiveAmbient = GsonHelper.getAsBoolean(jsonObject, \"ambientToFullbright\");\n            deprecationWarningsBuilder.put(\"ambientToFullbright\", \"emissive_ambient\");\n        }\n        if (jsonObject.has(\"materialLibraryOverride\"))\n        {\n            mtlOverride = GsonHelper.getAsString(jsonObject, \"materialLibraryOverride\");\n            deprecationWarningsBuilder.put(\"materialLibraryOverride\", \"mtl_override\");\n        }\n\n        return loadModel(new ObjModel.ModelSettings(new ResourceLocation(modelLocation), automaticCulling, shadeQuads, flipV, emissiveAmbient, mtlOverride,allowHomonymObjectName), deprecationWarningsBuilder.build());\n    }", ["Formatting: spaces after commas.\r\n```suggestion\r\n        boolean allowHomonymObjectName = GsonHelper.getAsBoolean(jsonObject, \"allow_homonym_object_name\", false);\r\n```"]], ["    @Override\n    public ObjModel read(JsonObject jsonObject, JsonDeserializationContext deserializationContext)\n    {\n        if (!jsonObject.has(\"model\"))\n            throw new JsonParseException(\"OBJ Loader requires a 'model' key that points to a valid .OBJ model.\");\n\n        String modelLocation = jsonObject.get(\"model\").getAsString();\n\n        boolean automaticCulling = GsonHelper.getAsBoolean(jsonObject, \"automatic_culling\", true);\n        boolean shadeQuads = GsonHelper.getAsBoolean(jsonObject, \"shade_quads\", true);\n        boolean flipV = GsonHelper.getAsBoolean(jsonObject, \"flip_v\", false);\n        boolean emissiveAmbient = GsonHelper.getAsBoolean(jsonObject, \"emissive_ambient\", true);\n        String mtlOverride = GsonHelper.getAsString(jsonObject, \"mtl_override\", null);\n        boolean allowHomonymObjectName = GsonHelper.getAsBoolean(jsonObject,\"allow_homonym_object_name\",false);\n\n        // TODO: Deprecated names. To be removed in 1.20\n        var deprecationWarningsBuilder = ImmutableMap.<String, String>builder();\n        if (jsonObject.has(\"detectCullableFaces\"))\n        {\n            automaticCulling = GsonHelper.getAsBoolean(jsonObject, \"detectCullableFaces\");\n            deprecationWarningsBuilder.put(\"detectCullableFaces\", \"automatic_culling\");\n        }\n        if (jsonObject.has(\"diffuseLighting\"))\n        {\n            shadeQuads = GsonHelper.getAsBoolean(jsonObject, \"diffuseLighting\");\n            deprecationWarningsBuilder.put(\"diffuseLighting\", \"shade_quads\");\n        }\n        if (jsonObject.has(\"flip-v\"))\n        {\n            flipV = GsonHelper.getAsBoolean(jsonObject, \"flip-v\");\n            deprecationWarningsBuilder.put(\"flip-v\", \"flip_v\");\n        }\n        if (jsonObject.has(\"ambientToFullbright\"))\n        {\n            emissiveAmbient = GsonHelper.getAsBoolean(jsonObject, \"ambientToFullbright\");\n            deprecationWarningsBuilder.put(\"ambientToFullbright\", \"emissive_ambient\");\n        }\n        if (jsonObject.has(\"materialLibraryOverride\"))\n        {\n            mtlOverride = GsonHelper.getAsString(jsonObject, \"materialLibraryOverride\");\n            deprecationWarningsBuilder.put(\"materialLibraryOverride\", \"mtl_override\");\n        }\n\n        return loadModel(new ObjModel.ModelSettings(new ResourceLocation(modelLocation), automaticCulling, shadeQuads, flipV, emissiveAmbient, mtlOverride,allowHomonymObjectName), deprecationWarningsBuilder.build());\n    }", ["Formatting: spaces after commas.\r\n```suggestion\r\n        return loadModel(new ObjModel.ModelSettings(new ResourceLocation(modelLocation), automaticCulling, shadeQuads, flipV, emissiveAmbient, mtlOverride, allowHomonymObjectName), deprecationWarningsBuilder.build());\r\n```"]], ["    @Override\n    public IOGuarantees getIOGuarantees()\n    {\n        return IOGuarantees.STRICT;\n    }", ["I wonder if some implementations might override methods in a way that make the handler not strict anymore. However I don't think we should do anything about it cause it wouldn't be practical."]], ["    @Override\n    public IOGuarantees getIOGuarantees()\n    {\n        var guarantees = IOGuarantees.STRICT;\n        for (var handler : itemHandler)\n            guarantees = IOGuarantees.leastStrict(guarantees, handler.getIOGuarantees());\n        return guarantees;\n    }", ["This implementation is wrong if some of the inventories are linked, which can't really be tested for."]], ["    @Override\n    public boolean isItemValid(int slot, @NotNull ItemStack stack)\n    {\n        int slot1 = getSlot(inv, slot, side);\n        return slot1 == -1 ? false : inv.canPlaceItem(slot1, stack); // TODO: 1.20 - Change this to the face-aware method\n    }", ["Couldn't this be considered a bug in Forge, and as such anyone relying on the old behavior would be doing so wrongly? Hence it wouldn't be a breaking change."]], ["    public CombinedInvWrapper(IItemHandlerModifiable... itemHandler)\n    {\n        this(IOGuarantees.NONE, itemHandler);\n    }", ["Might want a `TODO 1.20: remove to encourage broader support of IOGuarantees` ?"]]]